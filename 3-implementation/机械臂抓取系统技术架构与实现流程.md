# æœºæ¢°è‡‚æŠ“å–ç³»ç»ŸæŠ€æœ¯æ¶æ„ä¸å®ç°æµç¨‹

## æ–‡æ¡£ä¿¡æ¯

**ç‰ˆæœ¬**ï¼šv1.1  
**æ—¥æœŸ**ï¼š2025 å¹´ 1 æœˆ  
**æœ€åæ›´æ–°**ï¼š2025 å¹´ 1 æœˆ  
**é€‚ç”¨é¡¹ç›®**ï¼š3C é¢†åŸŸè§†è§‰å¼•å¯¼æœºæ¢°è‡‚æŠ“å–ç³»ç»Ÿ  
**æŠ€æœ¯æ ˆ**ï¼šROS2 Humble + Gazebo + MoveIt2 + OpenCV + PCL  

---

## ğŸ’» é…å¥—ä»£ç ä»“åº“

**GitHub**ï¼š`https://github.com/your-org/grasp-system` _(å ä½ç¬¦ï¼Œè¯·æ›¿æ¢ä¸ºå®é™…ä»“åº“åœ°å€)_

### ä»“åº“ç»“æ„

```
grasp_system/
â”œâ”€â”€ README.md                       # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ LICENSE                         # å¼€æºåè®®
â”œâ”€â”€ docker/                         # Docker é…ç½®
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â””â”€â”€ docker-entrypoint.sh
â”œâ”€â”€ src/                            # ROS2 åŠŸèƒ½åŒ…
â”‚   â”œâ”€â”€ grasp_perception/           # æ„ŸçŸ¥æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ grasp_perception/
â”‚   â”‚   â”‚   â”œâ”€â”€ detection.py       # YOLO æ£€æµ‹å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ point_cloud.py     # ç‚¹äº‘å¤„ç†
â”‚   â”‚   â”‚   â””â”€â”€ pose_estimation.py # ä½å§¿ä¼°è®¡
â”‚   â”‚   â”œâ”€â”€ package.xml
â”‚   â”‚   â””â”€â”€ setup.py
â”‚   â”œâ”€â”€ grasp_planning/             # è§„åˆ’æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ grasp_planning/
â”‚   â”‚   â”‚   â”œâ”€â”€ grasp_planner.py   # æŠ“å–è§„åˆ’å™¨
â”‚   â”‚   â”‚   â””â”€â”€ motion_planner.py  # è¿åŠ¨è§„åˆ’å™¨
â”‚   â”‚   â”œâ”€â”€ package.xml
â”‚   â”‚   â””â”€â”€ setup.py
â”‚   â”œâ”€â”€ grasp_control/              # æ§åˆ¶æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ grasp_control/
â”‚   â”‚   â”‚   â”œâ”€â”€ arm_controller.py  # æœºæ¢°è‡‚æ§åˆ¶
â”‚   â”‚   â”‚   â””â”€â”€ gripper_controller.py # å¤¹çˆªæ§åˆ¶
â”‚   â”‚   â”œâ”€â”€ package.xml
â”‚   â”‚   â””â”€â”€ setup.py
â”‚   â””â”€â”€ grasp_bringup/              # å¯åŠ¨è„šæœ¬
â”‚       â”œâ”€â”€ launch/
â”‚       â”‚   â”œâ”€â”€ grasp_system.launch.py
â”‚       â”‚   â”œâ”€â”€ perception.launch.py
â”‚       â”‚   â”œâ”€â”€ planning.launch.py
â”‚       â”‚   â””â”€â”€ gazebo.launch.py
â”‚       â”œâ”€â”€ config/
â”‚       â””â”€â”€ package.xml
â”œâ”€â”€ config/                         # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ cameras/
â”‚   â”‚   â””â”€â”€ d435i.yaml
â”‚   â”œâ”€â”€ robots/
â”‚   â”‚   â””â”€â”€ ur5e.yaml
â”‚   â”œâ”€â”€ perception/
â”‚   â”‚   â””â”€â”€ yolo_config.yaml
â”‚   â””â”€â”€ system.yaml
â”œâ”€â”€ models/                         # è®­ç»ƒæ¨¡å‹
â”‚   â”œâ”€â”€ yolov8_3c.pt
â”‚   â””â”€â”€ graspnet_checkpoint.pth
â”œâ”€â”€ urdf/                           # æœºå™¨äººæè¿°
â”‚   â”œâ”€â”€ ur5e/
â”‚   â””â”€â”€ robotiq_2f_85/
â”œâ”€â”€ worlds/                         # Gazebo åœºæ™¯
â”‚   â””â”€â”€ 3c_workspace.world
â”œâ”€â”€ datasets/                       # æ•°æ®é›†
â”‚   â”œâ”€â”€ 3c_detection/
â”‚   â””â”€â”€ 3c_grasps/
â”œâ”€â”€ scripts/                        # å·¥å…·è„šæœ¬
â”‚   â”œâ”€â”€ collect_data.py
â”‚   â””â”€â”€ train_model.py
â”œâ”€â”€ test/                           # æµ‹è¯•ä»£ç 
â”‚   â”œâ”€â”€ test_detection.py
â”‚   â”œâ”€â”€ test_planning.py
â”‚   â””â”€â”€ test_integration.py
â”œâ”€â”€ docs/                           # æ–‡æ¡£
â”‚   â”œâ”€â”€ æœºæ¢°è‡‚æŠ“å–ç³»ç»ŸæŠ€æœ¯æ¶æ„ä¸å®ç°æµç¨‹.md
â”‚   â””â”€â”€ API.md
â””â”€â”€ requirements.txt                # Python ä¾èµ–
```

### å¿«é€Ÿå¼€å§‹

```bash
# 1. å…‹éš†ä»“åº“
git clone https://github.com/your-org/grasp-system.git
cd grasp-system

# 2. æ„å»º Docker é•œåƒ
docker-compose build

# 3. å¯åŠ¨ç³»ç»Ÿï¼ˆä»¿çœŸæ¨¡å¼ï¼‰
docker-compose up

# 4. è¿è¡Œæµ‹è¯•
docker-compose exec grasp_system bash
pytest test/

# 5. è¿è¡Œå•ä¸ª demo
ros2 launch grasp_bringup grasp_system.launch.py
```

**æ³¨æ„**ï¼šå®Œæ•´ä»£ç å°†åœ¨é¡¹ç›®å®æ–½è¿‡ç¨‹ä¸­é€æ­¥å¼€å‘å¹¶ä¸Šä¼ åˆ°ä»“åº“ã€‚

---

## ğŸ” å¿«é€ŸæŸ¥æ‰¾è¡¨

| æˆ‘æƒ³äº†è§£... | è·³è½¬åˆ°ç« èŠ‚ | å…³é”®è¯ |
|-----------|----------|--------|
| **ç³»ç»Ÿæ¶æ„** | [ç¬¬ 1 èŠ‚](#1-ç³»ç»Ÿæ¶æ„æ€»è§ˆ) | 5å±‚æ¶æ„ã€æ¨¡å—åˆ’åˆ† |
| **å¦‚ä½•é€‰æ‹© 2D æ£€æµ‹ç®—æ³•** | [ç¬¬ 2.2.1 èŠ‚](#221-2d-è§†è§‰æ¨¡å—) | YOLOã€ArUcoã€Mask R-CNN |
| **å¦‚ä½•é€‰æ‹© 3D ç›¸æœº** | [ç¬¬ 2.2.2 èŠ‚](#222-3d-è§†è§‰æ¨¡å—) | RealSenseã€Kinectã€ZED |
| **ä½å§¿ä¼°è®¡æ–¹æ³•å¯¹æ¯”** | [ç¬¬ 2.3 èŠ‚](#23-ä½å§¿ä¼°è®¡æŠ€æœ¯æ ˆ) | ICPã€PnPã€FoundationPose |
| **æŠ“å–è§„åˆ’ç®—æ³•å¯¹æ¯”** | [ç¬¬ 2.4 èŠ‚](#24-æŠ“å–è§„åˆ’æŠ€æœ¯æ ˆ) | GraspNetã€Dex-Netã€å¼ºåŒ–å­¦ä¹  |
| **è¿åŠ¨è§„åˆ’é…ç½®** | [ç¬¬ 2.5 èŠ‚](#25-è¿åŠ¨è§„åˆ’æŠ€æœ¯æ ˆ) | RRTã€PRMã€OMPL |
| **å®Œæ•´æŠ“å–æµç¨‹** | [ç¬¬ 3 èŠ‚](#3-æŠ“å–æµç¨‹è¯¦è§£) | 8æ­¥æµç¨‹ã€Mermaidæµç¨‹å›¾ |
| **ç³»ç»Ÿåˆå§‹åŒ–ä»£ç ** | [ç¬¬ 3.2 èŠ‚](#32-å…³é”®æµç¨‹èŠ‚ç‚¹è¯¦è§£) | ROS2åˆå§‹åŒ–ã€Homeä½ç½® |
| **YOLO æ£€æµ‹ä»£ç ** | [ç¬¬ 4.1 èŠ‚](#41-2d-è§†è§‰å¤„ç†æµç¨‹) | ObjectDetectorç±» |
| **ç‚¹äº‘åˆ†å‰²ä»£ç ** | [ç¬¬ 4.2 èŠ‚](#42-3d-è§†è§‰å¤„ç†æµç¨‹) | PointCloudProcessor |
| **ICP é…å‡†ä»£ç ** | [ç¬¬ 5.1 èŠ‚](#51-icp-é…å‡†è¯¦è§£) | ICPPoseEstimator |
| **æ·±åº¦å­¦ä¹ ä½å§¿ä¼°è®¡** | [ç¬¬ 5.2 èŠ‚](#52-æ·±åº¦å­¦ä¹ ä½å§¿ä¼°è®¡foundationpose) | DLPoseEstimator |
| **GraspNet ä½¿ç”¨** | [ç¬¬ 6.1 èŠ‚](#61-graspnet-é›†æˆ) | GraspNetPlanner |
| **MoveIt2 é…ç½®** | [ç¬¬ 7.1 èŠ‚](#71-moveit2-é…ç½®) | moveit_config.yaml |
| **ros2_control é…ç½®** | [ç¬¬ 7.2 èŠ‚](#72-ros2_control-é…ç½®) | controller.yaml |
| **æ‰§è¡ŒçŠ¶æ€æœº** | [ç¬¬ 8.1 èŠ‚](#81-æ‰§è¡ŒçŠ¶æ€æœº) | GraspStateMachine |
| **ROS2 è¯é¢˜åˆ—è¡¨** | [ç¬¬ 9.1 èŠ‚](#91-ros2-è¯é¢˜æ¶æ„) | Topicsã€Servicesã€Actions |
| **æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”** | [ç¬¬ 10 èŠ‚](#10-å…³é”®æŠ€æœ¯é€‰å‹å¯¹æ¯”) | è§†è§‰ã€ä½å§¿ã€æŠ“å–æ–¹æ³• |
| **é”™è¯¯å¤„ç†ç­–ç•¥** | [ç¬¬ 11 èŠ‚](#11-é”™è¯¯å¤„ç†ä¸æ¢å¤ç­–ç•¥) | é‡è¯•ã€å®‰å…¨æœºåˆ¶ |
| **YOLO è®­ç»ƒ** | [ç¬¬ 12 èŠ‚](#12-æ•°æ®é›†å‡†å¤‡ä¸æ¨¡å‹è®­ç»ƒ) | æ•°æ®é›†ã€æ ‡æ³¨ã€è®­ç»ƒè„šæœ¬ |
| **GraspNet æ•°æ®é‡‡é›†** | [ç¬¬ 12.2 èŠ‚](#122-graspnet-æ•°æ®é›†å‡†å¤‡) | ä»¿çœŸæ•°æ®ã€çœŸå®æ•°æ® |
| **ä¸“ä¸šæœ¯è¯­è§£é‡Š** | [æœ¯è¯­è¡¨](#-æœ¯è¯­è¡¨) | ICPã€RRTã€PCLã€IKç­‰ |

### æŒ‰è§’è‰²æ¨èé˜…è¯»è·¯çº¿

#### ğŸ“Š é¡¹ç›®ç»ç†/æŠ€æœ¯è´Ÿè´£äºº
- **é‡ç‚¹é˜…è¯»**ï¼šç¬¬ 1 èŠ‚ï¼ˆæ¶æ„ï¼‰ã€ç¬¬ 2 èŠ‚ï¼ˆæŠ€æœ¯æ ˆï¼‰ã€ç¬¬ 10 èŠ‚ï¼ˆæŠ€æœ¯å¯¹æ¯”ï¼‰
- **é˜…è¯»æ—¶é—´**ï¼š~30 åˆ†é’Ÿ
- **ç›®æ ‡**ï¼šäº†è§£æ•´ä½“æ¶æ„ã€æŠ€æœ¯é€‰å‹ã€é¡¹ç›®å¯è¡Œæ€§

#### ğŸ¤– ç®—æ³•å·¥ç¨‹å¸ˆ
- **é‡ç‚¹é˜…è¯»**ï¼šç¬¬ 4 èŠ‚ï¼ˆè§†è§‰ï¼‰ã€ç¬¬ 5 èŠ‚ï¼ˆä½å§¿ä¼°è®¡ï¼‰ã€ç¬¬ 6 èŠ‚ï¼ˆæŠ“å–è§„åˆ’ï¼‰ã€ç¬¬ 12 èŠ‚ï¼ˆæ•°æ®é›†ï¼‰
- **é˜…è¯»æ—¶é—´**ï¼š~90 åˆ†é’Ÿ
- **ç›®æ ‡**ï¼šæŒæ¡æ„ŸçŸ¥ç®—æ³•ã€æŠ“å–è§„åˆ’ã€æ¨¡å‹è®­ç»ƒ

#### ğŸ› ï¸ æœºå™¨äººå·¥ç¨‹å¸ˆ
- **é‡ç‚¹é˜…è¯»**ï¼šç¬¬ 7 èŠ‚ï¼ˆè¿åŠ¨è§„åˆ’ï¼‰ã€ç¬¬ 8 èŠ‚ï¼ˆæ‰§è¡Œæ§åˆ¶ï¼‰ã€ç¬¬ 9 èŠ‚ï¼ˆé€šä¿¡ï¼‰ã€ç¬¬ 11 èŠ‚ï¼ˆé”™è¯¯å¤„ç†ï¼‰
- **é˜…è¯»æ—¶é—´**ï¼š~90 åˆ†é’Ÿ
- **ç›®æ ‡**ï¼šæŒæ¡è¿åŠ¨è§„åˆ’ã€è½¨è¿¹æ§åˆ¶ã€ç³»ç»Ÿé›†æˆ

#### ğŸ“ æ–°æ‰‹å¼€å‘è€…
- **æ¨èé¡ºåº**ï¼šç¬¬ 1 èŠ‚ â†’ ç¬¬ 3 èŠ‚ â†’ ç¬¬ 10 èŠ‚ï¼ˆç†è§£æ•´ä½“ï¼‰â†’ å…¶ä»–èŠ‚ï¼ˆæ·±å…¥ç»†èŠ‚ï¼‰
- **é˜…è¯»æ—¶é—´**ï¼š~3 å°æ—¶
- **ç›®æ ‡**ï¼šå»ºç«‹å®Œæ•´çš„çŸ¥è¯†ä½“ç³»

---

## ç›®å½•

1. [ç³»ç»Ÿæ¶æ„æ€»è§ˆ](#1-ç³»ç»Ÿæ¶æ„æ€»è§ˆ)
2. [å®Œæ•´æŠ€æœ¯æ ˆ](#2-å®Œæ•´æŠ€æœ¯æ ˆ)
3. [æŠ“å–æµç¨‹è¯¦è§£](#3-æŠ“å–æµç¨‹è¯¦è§£)
4. [è§†è§‰æ„ŸçŸ¥æ¨¡å—](#4-è§†è§‰æ„ŸçŸ¥æ¨¡å—)
5. [ä½å§¿ä¼°è®¡ä¸ä¼˜åŒ–](#5-ä½å§¿ä¼°è®¡ä¸ä¼˜åŒ–)
6. [æŠ“å–è§„åˆ’æ¨¡å—](#6-æŠ“å–è§„åˆ’æ¨¡å—)
7. [è¿åŠ¨è§„åˆ’ä¸æ§åˆ¶](#7-è¿åŠ¨è§„åˆ’ä¸æ§åˆ¶)
8. [æ‰§è¡Œä¸åé¦ˆ](#8-æ‰§è¡Œä¸åé¦ˆ)
9. [æ•°æ®æµä¸é€šä¿¡](#9-æ•°æ®æµä¸é€šä¿¡)
10. [å…³é”®æŠ€æœ¯é€‰å‹å¯¹æ¯”](#10-å…³é”®æŠ€æœ¯é€‰å‹å¯¹æ¯”)
11. [é”™è¯¯å¤„ç†ä¸æ¢å¤ç­–ç•¥](#11-é”™è¯¯å¤„ç†ä¸æ¢å¤ç­–ç•¥) â­ æ–°å¢
12. [æ•°æ®é›†å‡†å¤‡ä¸æ¨¡å‹è®­ç»ƒ](#12-æ•°æ®é›†å‡†å¤‡ä¸æ¨¡å‹è®­ç»ƒ) â­ æ–°å¢
13. [æœ¯è¯­è¡¨](#-æœ¯è¯­è¡¨) â­ æ–°å¢

---

## 1. ç³»ç»Ÿæ¶æ„æ€»è§ˆ

### 1.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ä¸Šå±‚åº”ç”¨å±‚ï¼ˆApplication Layerï¼‰                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ä»»åŠ¡è°ƒåº¦å™¨   â”‚  â”‚ ç”¨æˆ·ç•Œé¢    â”‚  â”‚ æ•°æ®è®°å½•å™¨   â”‚  â”‚ æ€§èƒ½ç›‘æ§    â”‚ â”‚
â”‚  â”‚Task Schedulerâ”‚  â”‚  GUI/CLI   â”‚  â”‚Data Logger  â”‚  â”‚ Monitor     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ ROS2 Topics/Services
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å†³ç­–è§„åˆ’å±‚ï¼ˆPlanning Layerï¼‰                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  æŠ“å–è§„åˆ’å™¨       â”‚ â†â”€â”€â”€â”€â†’ â”‚  è¿åŠ¨è§„åˆ’å™¨       â”‚                  â”‚
â”‚  â”‚ Grasp Planner    â”‚         â”‚ Motion Planner   â”‚                  â”‚
â”‚  â”‚ - å€™é€‰æŠ“å–ç”Ÿæˆ    â”‚         â”‚ - MoveIt2        â”‚                  â”‚
â”‚  â”‚ - æŠ“å–è´¨é‡è¯„ä¼°    â”‚         â”‚ - ç¢°æ’æ£€æµ‹        â”‚                  â”‚
â”‚  â”‚ - æŠ“å–ç‚¹é€‰æ‹©      â”‚         â”‚ - è½¨è¿¹ä¼˜åŒ–        â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ Goal Pose
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ„ŸçŸ¥å¤„ç†å±‚ï¼ˆPerception Layerï¼‰                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 2D è§†è§‰    â”‚  â”‚ 3D è§†è§‰    â”‚  â”‚ ä½å§¿ä¼°è®¡    â”‚  â”‚ ä½å§¿ä¼˜åŒ–    â”‚   â”‚
â”‚  â”‚ 2D Vision  â”‚  â”‚ 3D Vision  â”‚  â”‚Pose Estim. â”‚  â”‚Pose Refine.â”‚   â”‚
â”‚  â”‚- ç‰©ä½“æ£€æµ‹   â”‚  â”‚- ç‚¹äº‘å¤„ç†   â”‚  â”‚- ICPé…å‡†   â”‚  â”‚- å¡å°”æ›¼æ»¤æ³¢ â”‚   â”‚
â”‚  â”‚- åˆ†å‰²       â”‚  â”‚- å¹³é¢æå–   â”‚  â”‚- PnPæ±‚è§£   â”‚  â”‚- Bundle Adjâ”‚   â”‚
â”‚  â”‚- ç‰¹å¾æå–   â”‚  â”‚- èšç±»       â”‚  â”‚- æ·±åº¦å­¦ä¹    â”‚  â”‚- å¤šè§†è§’èåˆ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ Sensor Data
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¼ æ„Ÿå™¨å±‚ï¼ˆSensor Layerï¼‰                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ RGB ç›¸æœº   â”‚  â”‚ æ·±åº¦ç›¸æœº    â”‚  â”‚ åŠ›/åŠ›çŸ©ä¼ æ„Ÿå™¨â”‚ â”‚ å…³èŠ‚ç¼–ç å™¨  â”‚   â”‚
â”‚  â”‚RGB Camera  â”‚  â”‚Depth Cameraâ”‚  â”‚Force Sensorâ”‚  â”‚Joint Encoderâ”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ Control Commands
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ‰§è¡Œæ§åˆ¶å±‚ï¼ˆExecution Layerï¼‰                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  æœºæ¢°è‡‚æ§åˆ¶å™¨     â”‚ â†â”€â”€â”€â”€â†’ â”‚  å¤¹çˆªæ§åˆ¶å™¨       â”‚                  â”‚
â”‚  â”‚  Arm Controller  â”‚         â”‚Gripper Controllerâ”‚                  â”‚
â”‚  â”‚ - å…³èŠ‚æ§åˆ¶        â”‚         â”‚ - å¼€åˆæ§åˆ¶        â”‚                  â”‚
â”‚  â”‚ - ç¬›å¡å°”æ§åˆ¶      â”‚         â”‚ - åŠ›æ§åˆ¶          â”‚                  â”‚
â”‚  â”‚ - åŠ›æ§æ¨¡å¼        â”‚         â”‚ - ä½ç½®åé¦ˆ        â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ Hardware Interface
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç¡¬ä»¶å±‚ï¼ˆHardware Layerï¼‰                            â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚            â”‚  UR5e æœºæ¢°è‡‚  â”‚         â”‚ Robotiq å¤¹çˆª â”‚                â”‚
â”‚            â”‚  (Gazeboä»¿çœŸ) â”‚         â”‚  (ä»¿çœŸæ¨¡å‹)   â”‚                â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.2 æ¨¡å—åŠŸèƒ½åˆ’åˆ†

| æ¨¡å—å±‚ | æ ¸å¿ƒåŠŸèƒ½ | è¾“å…¥ | è¾“å‡º | å…³é”®æŠ€æœ¯ |
|--------|---------|------|------|---------|
| **åº”ç”¨å±‚** | ä»»åŠ¡ç®¡ç†ã€ç”¨æˆ·äº¤äº’ | ç”¨æˆ·æŒ‡ä»¤ | ä»»åŠ¡åºåˆ— | ROS2 Actions |
| **å†³ç­–å±‚** | æŠ“å–è§„åˆ’ã€è¿åŠ¨è§„åˆ’ | ç‰©ä½“ä½å§¿ | è¿åŠ¨è½¨è¿¹ | MoveIt2, OMPL |
| **æ„ŸçŸ¥å±‚** | è§†è§‰å¤„ç†ã€ä½å§¿ä¼°è®¡ | ä¼ æ„Ÿå™¨æ•°æ® | ç‰©ä½“ä½å§¿ | OpenCV, PCL |
| **æ‰§è¡Œå±‚** | è¿åŠ¨æ§åˆ¶ã€åŠ›æ§åˆ¶ | è½¨è¿¹æŒ‡ä»¤ | å…³èŠ‚å‘½ä»¤ | ros2_control |
| **ç¡¬ä»¶å±‚** | æœºæ¢°è‡‚ã€ä¼ æ„Ÿå™¨ | æ§åˆ¶ä¿¡å· | çŠ¶æ€åé¦ˆ | Gazebo, UR Driver |

---

## 2. å®Œæ•´æŠ€æœ¯æ ˆ

### 2.1 æ ¸å¿ƒæ¡†æ¶

| ç»„ä»¶ç±»å‹ | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬ | ç”¨é€” | ç†ç”± |
|---------|---------|------|------|------|
| **æ“ä½œç³»ç»Ÿ** | Ubuntu | 22.04 LTS | åŸºç¡€ç¯å¢ƒ | ROS2 Humble å®˜æ–¹æ”¯æŒ |
| **ä¸­é—´ä»¶** | ROS2 | Humble Hawksbill | æœºå™¨äººæ¡†æ¶ | LTS ç‰ˆæœ¬ï¼Œç”Ÿæ€æˆç†Ÿ |
| **ä»¿çœŸå™¨** | Gazebo | Classic 11 / Sim | ç‰©ç†ä»¿çœŸ | ROS2 é›†æˆå®Œå–„ |
| **è¿åŠ¨è§„åˆ’** | MoveIt2 | 2.5+ | è·¯å¾„è§„åˆ’ | ROS2 æ ‡å‡†è§„åˆ’æ¡†æ¶ |
| **ç¼–ç¨‹è¯­è¨€** | Python | 3.10 | å¿«é€Ÿå¼€å‘ | åŸå‹éªŒè¯ã€ç®—æ³•é›†æˆ |
|  | C++ | 17 | æ€§èƒ½å…³é”®æ¨¡å— | å®æ—¶æ§åˆ¶ã€ç‚¹äº‘å¤„ç† |

---

### 2.2 è§†è§‰æ„ŸçŸ¥æŠ€æœ¯æ ˆ

#### 2.2.1 2D è§†è§‰æ¨¡å—

| åŠŸèƒ½æ¨¡å— | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬ | åº”ç”¨åœºæ™¯ | æ€§èƒ½æŒ‡æ ‡ |
|---------|---------|------|---------|---------|
| **å›¾åƒå¤„ç†** | OpenCV | 4.8+ | åŸºç¡€å›¾åƒå¤„ç† | CPU/GPU åŠ é€Ÿ |
| **ç‰©ä½“æ£€æµ‹** | YOLO v8 | 8.0 | å®æ—¶ç›®æ ‡æ£€æµ‹ | 30 FPS @ 640Ã—480 |
|  | YOLO v5 | 7.0 | è½»é‡çº§æ£€æµ‹ | 60 FPS @ 640Ã—480 |
| **å®ä¾‹åˆ†å‰²** | Mask R-CNN | PyTorch | ç²¾ç¡®åˆ†å‰² | 10 FPS @ 640Ã—480 |
|  | YOLOv8-Seg | 8.0 | å®æ—¶åˆ†å‰² | 25 FPS @ 640Ã—480 |
| **ç‰¹å¾æ£€æµ‹** | ORB | OpenCV | å¿«é€Ÿç‰¹å¾ç‚¹ | å®æ—¶ |
|  | SIFT | OpenCV | é«˜ç²¾åº¦ç‰¹å¾ | å‡†å®æ—¶ |
| **è¾¹ç¼˜æ£€æµ‹** | Canny | OpenCV | è½®å»“æå– | å®æ—¶ |
| **é¢œè‰²åˆ†å‰²** | HSV Threshold | OpenCV | ç®€å•åœºæ™¯ | å®æ—¶ï¼ˆ100+ FPSï¼‰ |
| **æ ‡è®°è¯†åˆ«** | ArUco | OpenCV | å¿«é€Ÿå®šä½ | å®æ—¶ |
| **æ·±åº¦å­¦ä¹ æ¡†æ¶** | PyTorch | 2.0+ | æ¨¡å‹è®­ç»ƒæ¨ç† | CUDA åŠ é€Ÿ |
|  | TensorRT | 8.6+ | æ¨¡å‹ä¼˜åŒ– | æ¨ç†åŠ é€Ÿ 3-5Ã— |

**æŠ€æœ¯é€‰å‹å»ºè®®**ï¼ˆæŒ‰æœˆåº¦é€’è¿›ï¼‰ï¼š

| é˜¶æ®µ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| **æœˆåº¦ 1ï¼ˆæ— è§†è§‰ï¼‰** | - | ç¡¬ç¼–ç åæ ‡ |
| **æœˆåº¦ 2ï¼ˆç®€å•è§†è§‰ï¼‰** | ArUco æ ‡è®° / HSV é¢œè‰²é˜ˆå€¼ | é›¶è®­ç»ƒï¼Œå¿«é€ŸéªŒè¯ |
| **æœˆåº¦ 3ï¼ˆæ·±åº¦å­¦ä¹ ï¼‰** | YOLO v8 + TensorRT | é²æ£’æ€§å¼ºï¼Œå®æ—¶æ€§å¥½ |

---

#### 2.2.2 3D è§†è§‰æ¨¡å—

| åŠŸèƒ½æ¨¡å— | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬ | åº”ç”¨åœºæ™¯ | æ€§èƒ½æŒ‡æ ‡ |
|---------|---------|------|---------|---------|
| **ç‚¹äº‘åº“** | PCL (Point Cloud Library) | 1.12+ | ç‚¹äº‘å¤„ç†åŸºç¡€ | C++ é«˜æ€§èƒ½ |
|  | Open3D | 0.18+ | Python å‹å¥½ | æ˜“ç”¨æ€§å¼º |
| **ç‚¹äº‘æ»¤æ³¢** | VoxelGrid | PCL | é™é‡‡æ · | 10-100Ã— åŠ é€Ÿ |
|  | PassThrough | PCL | åŒºåŸŸè£å‰ª | å®æ—¶ |
|  | StatisticalOutlierRemoval | PCL | å™ªå£°å»é™¤ | å‡†å®æ—¶ |
| **å¹³é¢æå–** | RANSAC | PCL | æ¡Œé¢æ£€æµ‹ | <100ms |
|  | Region Growing | PCL | å¹³é¢åˆ†å‰² | <200ms |
| **èšç±»åˆ†å‰²** | Euclidean Clustering | PCL | ç‰©ä½“åˆ†ç¦» | <50ms |
|  | DBSCAN | scikit-learn | å¯†åº¦èšç±» | çµæ´» |
| **é…å‡†ç®—æ³•** | ICP (Iterative Closest Point) | PCL | ç²¾ç»†é…å‡† | 1-5s |
|  | GICP (Generalized ICP) | PCL | é²æ£’é…å‡† | 2-10s |
|  | NDT (Normal Distributions Transform) | PCL | å¿«é€Ÿé…å‡† | 0.5-2s |
| **ç‰¹å¾æè¿°** | FPFH (Fast Point Feature Histograms) | PCL | å¿«é€Ÿæè¿°å­ | <100ms |
|  | SHOT (Signature of Histograms) | PCL | é«˜ç²¾åº¦æè¿°å­ | <500ms |
| **æ·±åº¦å­¦ä¹ ** | PointNet++ | PyTorch | ç‚¹äº‘è¯­ä¹‰åˆ†å‰² | GPU åŠ é€Ÿ |
|  | VoteNet | PyTorch | 3D ç‰©ä½“æ£€æµ‹ | GPU åŠ é€Ÿ |

**3D ç›¸æœºé€‰å‹**ï¼š

| ç›¸æœºå‹å· | æŠ€æœ¯åŸç† | åˆ†è¾¨ç‡ | ç²¾åº¦ | ä»·æ ¼ | æ¨èåœºæ™¯ |
|---------|---------|--------|------|------|---------|
| **Intel RealSense D435i** | åŒç›®ç»“æ„å…‰ | 1280Ã—720 | Â±2% @ 1m | $200 | **é€šç”¨é¦–é€‰** |
| **Kinect Azure** | ToF | 1024Ã—1024 | Â±1% @ 1m | $400 | å¤§åœºæ™¯ |
| **Orbbec Astra** | ç»“æ„å…‰ | 640Ã—480 | Â±3% @ 1m | $150 | æˆæœ¬æ•æ„Ÿ |
| **ZED 2i** | åŒç›®è§†è§‰ | 2208Ã—1242 | Â±1% @ 1m | $450 | é«˜ç²¾åº¦ |
| **ä»¿çœŸç›¸æœº** | Gazebo æ·±åº¦æ’ä»¶ | å¯é…ç½® | ç†æƒ³ | å…è´¹ | **æœˆåº¦ 1-2** |

---

### 2.3 ä½å§¿ä¼°è®¡æŠ€æœ¯æ ˆ

| æ–¹æ³•ç±»åˆ« | æŠ€æœ¯ | è¾“å…¥ | ç²¾åº¦ | é€Ÿåº¦ | é€‚ç”¨åœºæ™¯ |
|---------|------|------|------|------|---------|
| **2D æ–¹æ³•** | PnP (Perspective-n-Point) | 2D ç‰¹å¾ç‚¹ + æ·±åº¦ | Â±5mm | <10ms | å·²çŸ¥ CAD æ¨¡å‹ |
|  | Template Matching | RGB å›¾åƒ | Â±10mm | <50ms | è§„åˆ™å½¢çŠ¶ |
| **3D æ–¹æ³•** | ICP é…å‡† | ç‚¹äº‘ | Â±1mm | 1-5s | é«˜ç²¾åº¦éœ€æ±‚ |
|  | RANSAC + ICP | ç‚¹äº‘ | Â±2mm | 0.5-3s | æœ‰å™ªå£°åœºæ™¯ |
|  | NDT é…å‡† | ç‚¹äº‘ | Â±3mm | 0.2-1s | å¿«é€Ÿåœºæ™¯ |
| **æ·±åº¦å­¦ä¹ ** | PoseNet | RGB å›¾åƒ | Â±10mm | <20ms | ç«¯åˆ°ç«¯ |
|  | DenseFusion | RGB-D | Â±5mm | 100ms | 6D ä½å§¿ |
|  | FoundationPose | RGB-D | Â±2mm | 200ms | NVIDIA æœ€æ–° |
| **æ··åˆæ–¹æ³•** | 2D æ£€æµ‹ + 3D ç²¾é…å‡† | RGB-D | Â±2mm | 0.5-2s | **æ¨èæ–¹æ¡ˆ** |

---

### 2.4 æŠ“å–è§„åˆ’æŠ€æœ¯æ ˆ

| ç±»å‹ | æ–¹æ³• | è¾“å…¥ | è¾“å‡º | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|------|------|------|------|------|
| **åˆ†æå¼æ–¹æ³•** | Force Closure | ç‰©ä½“å‡ ä½• | æŠ“å–é…ç½® | ç†è®ºä¿è¯ | è®¡ç®—å¤æ‚ |
|  | Form Closure | ç‰©ä½“å‡ ä½• | æŠ“å–é…ç½® | ç¨³å®šæ€§é«˜ | éœ€ç²¾ç¡®æ¨¡å‹ |
| **é‡‡æ ·å¼æ–¹æ³•** | GraspIt! | ç‰©ä½“æ¨¡å‹ | å€™é€‰æŠ“å–ç‚¹ | æˆç†Ÿç¨³å®š | ä¾èµ–æ¨¡å‹ |
|  | éšæœºé‡‡æ · + è¯„ä¼° | ç‚¹äº‘ | æŠ“å–å§¿æ€ | æ³›åŒ–èƒ½åŠ›å¼º | æˆåŠŸç‡ä¸­ç­‰ |
| **å­¦ä¹ å¼æ–¹æ³•** | GraspNet (ç‚¹äº‘) | ç‚¹äº‘ | æŠ“å–å§¿æ€ + è´¨é‡ | æ³›åŒ–æ€§å¥½ | éœ€å¤§é‡æ•°æ® |
|  | Contact-GraspNet | ç‚¹äº‘ | æ¥è§¦ç‚¹ + å§¿æ€ | ç²¾åº¦é«˜ | GPU ä¾èµ– |
|  | Dex-Net (å›¾åƒ) | æ·±åº¦å›¾ | å¹³è¡Œå¤¹çˆªæŠ“å– | å¿«é€Ÿ | ä»…å¹³è¡Œå¤¹çˆª |
| **å¼ºåŒ–å­¦ä¹ ** | PPO/SAC | çŠ¶æ€è§‚æµ‹ | ç­–ç•¥ç½‘ç»œ | è‡ªä¸»å­¦ä¹  | è®­ç»ƒæ—¶é—´é•¿ |

**æœˆåº¦ 1-3 æ¨èè·¯å¾„**ï¼š

```
æœˆåº¦ 1ï¼šå›ºå®šæŠ“å–ç‚¹ï¼ˆç¡¬ç¼–ç ï¼‰
         â†“
æœˆåº¦ 2ï¼šArUco æ ‡è®°å®šä½ + ç®€å•æŠ“å–è§„åˆ™
         â†“
æœˆåº¦ 3ï¼šGraspNet ç‚¹äº‘æŠ“å– / YOLO + å¯å‘å¼è§„åˆ™
```

---

### 2.5 è¿åŠ¨è§„åˆ’æŠ€æœ¯æ ˆ

| å±‚æ¬¡ | æŠ€æœ¯ | åº“/æ¡†æ¶ | ç”¨é€” | æ€§èƒ½ |
|------|------|---------|------|------|
| **å…¨å±€è§„åˆ’** | RRT (Rapidly-exploring Random Tree) | OMPL | å¿«é€Ÿæ¢ç´¢ | ä¸­é€Ÿ |
|  | RRT* | OMPL | æ¸è¿›æœ€ä¼˜ | æ…¢é€Ÿ |
|  | PRM (Probabilistic Roadmap) | OMPL | é¢„æ„å»ºè·¯çº¿å›¾ | å¿«é€ŸæŸ¥è¯¢ |
|  | Pilz Industrial Motion | MoveIt2 | å·¥ä¸šæ ‡å‡†è¿åŠ¨ | å¿«é€Ÿ |
| **å±€éƒ¨è§„åˆ’** | Cartesian Path Planning | MoveIt2 | ç¬›å¡å°”ç›´çº¿ | å¿«é€Ÿ |
|  | Time-Optimal Trajectory | MoveIt2 | æ—¶é—´æœ€ä¼˜ | ä¸­é€Ÿ |
| **è½¨è¿¹ä¼˜åŒ–** | STOMP | MoveIt2 | å¹³æ»‘è½¨è¿¹ | æ…¢é€Ÿ |
|  | CHOMP | MoveIt2 | é¿éšœä¼˜åŒ– | ä¸­é€Ÿ |
|  | TrajOpt | MoveIt2 | çº¦æŸä¼˜åŒ– | æ…¢é€Ÿ |
| **é€†è¿åŠ¨å­¦** | KDL (Kinematics and Dynamics Library) | MoveIt2 | æ•°å€¼æ±‚è§£ | å¿«é€Ÿ |
|  | TRAC-IK | MoveIt2 | é²æ£’æ±‚è§£ | ä¸­é€Ÿ |
|  | IKFast | OpenRAVE | è§£æè§£ | **æœ€å¿«** |

**æ¨èé…ç½®**ï¼ˆMoveIt2ï¼‰ï¼š

```yaml
planning:
  pipeline: ompl  # è§„åˆ’ç®¡çº¿
  planner: RRTConnect  # å¿«é€Ÿè¿æ¥
  planning_time: 5.0  # è§„åˆ’æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
  max_velocity_scaling_factor: 0.5  # é€Ÿåº¦é™åˆ¶ 50%
  max_acceleration_scaling_factor: 0.3  # åŠ é€Ÿåº¦é™åˆ¶ 30%

kinematics:
  solver: TRAC-IK  # é€†è¿åŠ¨å­¦æ±‚è§£å™¨
  timeout: 0.05  # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
```

---

### 2.6 æ§åˆ¶æŠ€æœ¯æ ˆ

| æ§åˆ¶å±‚æ¬¡ | æ–¹æ³• | æ¡†æ¶ | é¢‘ç‡ | ç”¨é€” |
|---------|------|------|------|------|
| **é«˜å±‚æ§åˆ¶** | ä»»åŠ¡ç©ºé—´æ§åˆ¶ | MoveIt2 | 10-50 Hz | ä½å§¿ç›®æ ‡ |
|  | å…³èŠ‚ç©ºé—´æ§åˆ¶ | ros2_control | 100-500 Hz | å…³èŠ‚è§’ç›®æ ‡ |
| **ä¸­å±‚æ§åˆ¶** | è½¨è¿¹è·Ÿè¸ªæ§åˆ¶ | JointTrajectoryController | 100 Hz | è½¨è¿¹æ‰§è¡Œ |
|  | ç¬›å¡å°”æ§åˆ¶ | CartesianController | 100 Hz | æœ«ç«¯æ§åˆ¶ |
| **åº•å±‚æ§åˆ¶** | PID æ§åˆ¶ | ros2_control | 500-1000 Hz | å…³èŠ‚ä¼ºæœ |
|  | åŠ›/é˜»æŠ—æ§åˆ¶ | UR5e å†…ç½® | 500 Hz | æŸ”æ€§äº¤äº’ |
| **å¤¹çˆªæ§åˆ¶** | ä½ç½®æ§åˆ¶ | GripperActionController | 20 Hz | å¼€åˆæ§åˆ¶ |
|  | åŠ›æ§åˆ¶ | è‡ªå®šä¹‰æ§åˆ¶å™¨ | 100 Hz | åŠ›åº¦æ§åˆ¶ |

**ros2_control æ¶æ„**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Controller Manager (æ§åˆ¶å™¨ç®¡ç†å™¨)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚Joint Trajectoryâ”‚  â”‚Gripper Action  â”‚ â”‚
â”‚  â”‚   Controller   â”‚  â”‚   Controller   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Hardware Interface (ç¡¬ä»¶æ¥å£)     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   UR5e Driver  â”‚  â”‚ Robotiq Driver â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. æŠ“å–æµç¨‹è¯¦è§£

### 3.1 å®Œæ•´æµç¨‹å›¾ï¼ˆMermaid å¯è§†åŒ–ï¼‰

```mermaid
flowchart TD
    Start([å¼€å§‹æŠ“å–ä»»åŠ¡]) --> Init[ç³»ç»Ÿåˆå§‹åŒ–<br/>5-10ç§’]
    
    Init --> |å¯åŠ¨å®Œæˆ| Sense[åœºæ™¯æ„ŸçŸ¥<br/>0.1-1ç§’]
    
    subgraph Perception["ğŸ” æ„ŸçŸ¥é˜¶æ®µ"]
        Sense --> Acquire[é‡‡é›†å›¾åƒ/ç‚¹äº‘]
        Acquire --> Preprocess[é¢„å¤„ç†<br/>æ»¤æ³¢ã€è£å‰ª]
        Preprocess --> Detect[ç›®æ ‡æ£€æµ‹<br/>2D: YOLO<br/>3D: èšç±»]
    end
    
    Detect --> PoseEst[ä½å§¿ä¼°è®¡<br/>0.2-2ç§’]
    
    subgraph PoseEstimation["ğŸ“ ä½å§¿ä¼°è®¡"]
        PoseEst --> Coarse[ç²—å®šä½<br/>2Dâ†’3Dæ˜ å°„]
        Coarse --> Fine[ç²¾ç»†é…å‡†<br/>ICP/NDT]
        Fine --> Optimize[ä½å§¿ä¼˜åŒ–<br/>å¡å°”æ›¼æ»¤æ³¢]
    end
    
    Optimize --> GraspPlan[æŠ“å–è§„åˆ’<br/>0.1-5ç§’]
    
    subgraph GraspPlanning["ğŸ¤ æŠ“å–è§„åˆ’ - ä»»åŠ¡ç©ºé—´"]
        GraspPlan --> GenCand[ç”Ÿæˆå€™é€‰æŠ“å–<br/>é‡‡æ ·50-100ä¸ªç‚¹]
        GenCand --> EvalGrasp[è´¨é‡è¯„ä¼°<br/>å¯è¾¾æ€§ã€ç¢°æ’ã€ç¨³å®šæ€§]
        EvalGrasp --> SelectGrasp[é€‰æ‹©æœ€ä¼˜<br/>Top-1]
    end
    
    SelectGrasp --> |æŠ“å–é…ç½®| IKSolve{IKæ±‚è§£<br/>æœ‰è§£?}
    
    IKSolve -->|æ— è§£| RetryGrasp[å°è¯•æ¬¡ä¼˜å€™é€‰]
    RetryGrasp --> SelectGrasp
    IKSolve -->|æœ‰è§£| MotionPlan[è¿åŠ¨è§„åˆ’<br/>1-5ç§’]
    
    subgraph MotionPlanning["ğŸ›£ï¸ è¿åŠ¨è§„åˆ’ - é…ç½®ç©ºé—´"]
        MotionPlan --> PreGrasp[é¢„æŠ“å–è§„åˆ’<br/>RRT-Connect]
        PreGrasp --> Approach[æ¥è¿‘è§„åˆ’<br/>ç¬›å¡å°”ç›´çº¿]
        Approach --> Lift[æŠ¬èµ·è§„åˆ’<br/>é¿éšœ]
        Lift --> Place[æ”¾ç½®è§„åˆ’<br/>RRT-Connect]
    end
    
    Place --> |è½¨è¿¹ç”Ÿæˆ| Execute[è½¨è¿¹æ‰§è¡Œ<br/>5-15ç§’]
    
    subgraph Execution["âš™ï¸ æ‰§è¡Œæ§åˆ¶"]
        Execute --> P1[é˜¶æ®µ1: ç§»åŠ¨åˆ°é¢„æŠ“å–]
        P1 --> P2[é˜¶æ®µ2: æ‰“å¼€å¤¹çˆª]
        P2 --> P3[é˜¶æ®µ3: ä¸‹é™åˆ°æŠ“å–ç‚¹]
        P3 --> P4[é˜¶æ®µ4: é—­åˆå¤¹çˆª]
        P4 --> ForceCheck{åŠ›åé¦ˆ<br/>æ£€æŸ¥}
        ForceCheck -->|å¤±è´¥| Retry[é‡è¯•æŠ“å–<br/>æœ€å¤š3æ¬¡]
        Retry -.-> P3
        ForceCheck -->|æˆåŠŸ| P5[é˜¶æ®µ5: æŠ¬èµ·ç‰©ä½“]
        P5 --> P6[é˜¶æ®µ6: ç§»åŠ¨åˆ°ç›®æ ‡]
        P6 --> P7[é˜¶æ®µ7: ä¸‹é™]
        P7 --> P8[é˜¶æ®µ8: æ‰“å¼€å¤¹çˆª]
        P8 --> P9[é˜¶æ®µ9: æ’¤å›]
    end
    
    P9 --> Verify[ç»“æœéªŒè¯<br/>0.1-1ç§’]
    
    subgraph Verification["âœ… éªŒè¯"]
        Verify --> VisCheck[è§†è§‰éªŒè¯<br/>ç‰©ä½“ä½ç½®æ£€æŸ¥]
        VisCheck --> QualCheck[è´¨é‡æ£€æŸ¥<br/>è¯¯å·®è®¡ç®—]
        QualCheck --> Log[è®°å½•ç»“æœ<br/>æˆåŠŸ/å¤±è´¥/æ—¶é—´]
    end
    
    Log --> VerifyResult{éªŒè¯<br/>é€šè¿‡?}
    VerifyResult -->|å¤±è´¥| Failed[è®°å½•å¤±è´¥<br/>åˆ†æåŸå› ]
    VerifyResult -->|æˆåŠŸ| Success[ä»»åŠ¡æˆåŠŸ]
    
    Success --> NextTask{æ˜¯å¦æœ‰<br/>ä¸‹ä¸€ä¸ªä»»åŠ¡?}
    Failed --> NextTask
    
    NextTask -->|æ˜¯| Sense
    NextTask -->|å¦| Home[å›åˆ°Homeä½ç½®]
    Home --> End([ç»“æŸ])
    
    %% æ ·å¼å®šä¹‰
    classDef perceptionStyle fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    classDef planningStyle fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    classDef motionStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef execStyle fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    classDef verifyStyle fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    classDef decisionStyle fill:#ffe0b2,stroke:#e64a19,stroke-width:2px
    
    class Acquire,Preprocess,Detect perceptionStyle
    class Coarse,Fine,Optimize perceptionStyle
    class GenCand,EvalGrasp,SelectGrasp planningStyle
    class PreGrasp,Approach,Lift,Place motionStyle
    class P1,P2,P3,P4,P5,P6,P7,P8,P9 execStyle
    class VisCheck,QualCheck,Log verifyStyle
    class IKSolve,ForceCheck,VerifyResult,NextTask decisionStyle
```

**æµç¨‹å›¾è¯´æ˜**ï¼š

- ğŸ” **è“è‰²**ï¼šæ„ŸçŸ¥é˜¶æ®µï¼ˆå›¾åƒé‡‡é›†ã€ç‰©ä½“æ£€æµ‹ã€ä½å§¿ä¼°è®¡ï¼‰
- ğŸ¤ **é»„è‰²**ï¼šæŠ“å–è§„åˆ’ï¼ˆä»»åŠ¡ç©ºé—´ï¼Œç”ŸæˆæŠ“å–é…ç½®ï¼‰
- ğŸ›£ï¸ **ç´«è‰²**ï¼šè¿åŠ¨è§„åˆ’ï¼ˆé…ç½®ç©ºé—´ï¼Œç”Ÿæˆå…³èŠ‚è½¨è¿¹ï¼‰
- âš™ï¸ **ç»¿è‰²**ï¼šæ‰§è¡Œæ§åˆ¶ï¼ˆ9ä¸ªæ‰§è¡Œé˜¶æ®µï¼‰
- âœ… **ç²‰è‰²**ï¼šç»“æœéªŒè¯ï¼ˆè§†è§‰ç¡®è®¤ã€è´¨é‡æ£€æŸ¥ï¼‰
- ğŸ”¶ **æ©™è‰²**ï¼šå†³ç­–èŠ‚ç‚¹ï¼ˆåˆ†æ”¯åˆ¤æ–­ï¼‰

**å…¸å‹æ‰§è¡Œæ—¶é—´**ï¼šå•æ¬¡æŠ“å– ~17ç§’
- æ„ŸçŸ¥ï¼š1ç§’
- ä½å§¿ä¼°è®¡ï¼š1ç§’
- æŠ“å–è§„åˆ’ï¼š2ç§’
- è¿åŠ¨è§„åˆ’ï¼š3ç§’
- æ‰§è¡Œï¼š10ç§’

---

### 3.2 å®Œæ•´æµç¨‹å›¾ï¼ˆæ–‡æœ¬ç‰ˆï¼‰

```
å¼€å§‹
  â”‚
  â”œâ”€â†’ [1] ç³»ç»Ÿåˆå§‹åŒ–
  â”‚    - å¯åŠ¨ ROS2 èŠ‚ç‚¹
  â”‚    - åŠ è½½æœºæ¢°è‡‚/å¤¹çˆªé©±åŠ¨
  â”‚    - åˆå§‹åŒ–ä¼ æ„Ÿå™¨
  â”‚    - å›åˆ° Home ä½ç½®
  â”‚
  â”œâ”€â†’ [2] åœºæ™¯æ„ŸçŸ¥
  â”‚    â”œâ”€ 2.1 é‡‡é›†å›¾åƒ/ç‚¹äº‘
  â”‚    â”œâ”€ 2.2 é¢„å¤„ç†ï¼ˆæ»¤æ³¢ã€è£å‰ªï¼‰
  â”‚    â””â”€ 2.3 ç›®æ ‡æ£€æµ‹
  â”‚         - 2D æ£€æµ‹ï¼ˆYOLOï¼‰
  â”‚         - 3D åˆ†å‰²ï¼ˆç‚¹äº‘èšç±»ï¼‰
  â”‚
  â”œâ”€â†’ [3] ä½å§¿ä¼°è®¡
  â”‚    â”œâ”€ 3.1 ç²—å®šä½
  â”‚    â”‚    - 2D è¾¹ç•Œæ¡† â†’ 3D ROI
  â”‚    â”‚    - è´¨å¿ƒè®¡ç®—
  â”‚    â”œâ”€ 3.2 ç²¾ç»†é…å‡†
  â”‚    â”‚    - ICP / NDT
  â”‚    â”‚    - æ·±åº¦å­¦ä¹ ä½å§¿ä¼°è®¡
  â”‚    â””â”€ 3.3 ä½å§¿ä¼˜åŒ–
  â”‚         - å¡å°”æ›¼æ»¤æ³¢
  â”‚         - å¤šå¸§èåˆ
  â”‚
  â”œâ”€â†’ [4] æŠ“å–è§„åˆ’
  â”‚    â”œâ”€ 4.1 ç”Ÿæˆå€™é€‰æŠ“å–
  â”‚    â”‚    - é‡‡æ ·æŠ“å–ç‚¹
  â”‚    â”‚    - GraspNet æ¨ç†
  â”‚    â”œâ”€ 4.2 æŠ“å–è´¨é‡è¯„ä¼°
  â”‚    â”‚    - ç¢°æ’æ£€æµ‹
  â”‚    â”‚    - å¯è¾¾æ€§æ£€æŸ¥ï¼ˆIKï¼‰
  â”‚    â”‚    - ç¨³å®šæ€§è¯„åˆ†
  â”‚    â””â”€ 4.3 é€‰æ‹©æœ€ä¼˜æŠ“å–
  â”‚         - æŒ‰è¯„åˆ†æ’åº
  â”‚         - é€‰æ‹© Top-1
  â”‚
  â”œâ”€â†’ [5] è¿åŠ¨è§„åˆ’
  â”‚    â”œâ”€ 5.1 é¢„æŠ“å–è§„åˆ’
  â”‚    â”‚    - ç›®æ ‡ï¼šç‰©ä½“ä¸Šæ–¹ 10cm
  â”‚    â”‚    - ç®—æ³•ï¼šRRT-Connect
  â”‚    â”œâ”€ 5.2 æ¥è¿‘è§„åˆ’
  â”‚    â”‚    - ç›®æ ‡ï¼šæŠ“å–ç‚¹
  â”‚    â”‚    - ç®—æ³•ï¼šç¬›å¡å°”ç›´çº¿
  â”‚    â”œâ”€ 5.3 æŠ¬èµ·è§„åˆ’
  â”‚    â”‚    - ç›®æ ‡ï¼šå®‰å…¨é«˜åº¦
  â”‚    â”‚    - é¿éšœï¼šæ¡Œé¢ã€å…¶ä»–ç‰©ä½“
  â”‚    â””â”€ 5.4 æ”¾ç½®è§„åˆ’
  â”‚         - ç›®æ ‡ï¼šç›®æ ‡ä½ç½®
  â”‚         - ç®—æ³•ï¼šRRT-Connect
  â”‚
  â”œâ”€â†’ [6] è½¨è¿¹æ‰§è¡Œ
  â”‚    â”œâ”€ 6.1 ç§»åŠ¨åˆ°é¢„æŠ“å–
  â”‚    â”œâ”€ 6.2 æ‰“å¼€å¤¹çˆª
  â”‚    â”œâ”€ 6.3 ä¸‹é™åˆ°æŠ“å–ç‚¹
  â”‚    â”œâ”€ 6.4 é—­åˆå¤¹çˆª
  â”‚    â”‚    - åŠ›æ§æ¨¡å¼ï¼ˆæ£€æµ‹æ¥è§¦ï¼‰
  â”‚    â”œâ”€ 6.5 éªŒè¯æŠ“å–
  â”‚    â”‚    - åŠ›ä¼ æ„Ÿå™¨åé¦ˆ
  â”‚    â”‚    - è§†è§‰ç¡®è®¤
  â”‚    â”œâ”€ 6.6 æŠ¬èµ·ç‰©ä½“
  â”‚    â”œâ”€ 6.7 ç§»åŠ¨åˆ°ç›®æ ‡
  â”‚    â”œâ”€ 6.8 ä¸‹é™åˆ°æ”¾ç½®é«˜åº¦
  â”‚    â”œâ”€ 6.9 æ‰“å¼€å¤¹çˆªï¼ˆé‡Šæ”¾ï¼‰
  â”‚    â””â”€ 6.10 æ’¤å›å®‰å…¨ä½ç½®
  â”‚
  â”œâ”€â†’ [7] ç»“æœéªŒè¯
  â”‚    â”œâ”€ 7.1 è§†è§‰éªŒè¯
  â”‚    â”‚    - ç‰©ä½“æ˜¯å¦åœ¨ç›®æ ‡ä½ç½®
  â”‚    â”œâ”€ 7.2 è´¨é‡æ£€æŸ¥
  â”‚    â”‚    - ä½ç½®è¯¯å·®
  â”‚    â”‚    - å§¿æ€è¯¯å·®
  â”‚    â””â”€ 7.3 è®°å½•ç»“æœ
  â”‚         - æˆåŠŸ/å¤±è´¥
  â”‚         - æ‰§è¡Œæ—¶é—´
  â”‚         - é”™è¯¯ç±»å‹
  â”‚
  â””â”€â†’ [8] å¾ªç¯æˆ–ç»“æŸ
       - å¦‚æœ‰ä¸‹ä¸€ä¸ªç›®æ ‡ â†’ è¿”å›æ­¥éª¤ 2
       - å¦åˆ™ â†’ å›åˆ° Homeï¼Œç»“æŸ
```

---

### 3.3 å…³é”®æµç¨‹èŠ‚ç‚¹è¯¦è§£

#### èŠ‚ç‚¹ 1ï¼šç³»ç»Ÿåˆå§‹åŒ–ï¼ˆ5-10 ç§’ï¼‰

**ç›®çš„**ï¼šç¡®ä¿æ‰€æœ‰å­ç³»ç»Ÿæ­£å¸¸å·¥ä½œ

```python
# ä¼ªä»£ç ç¤ºä¾‹
def initialize_system():
    # 1. å¯åŠ¨ ROS2 èŠ‚ç‚¹
    rclpy.init()
    node = Node('grasp_system')
    
    # 2. è¿æ¥æœºæ¢°è‡‚
    arm = MoveItPy(node_name="moveit_py")
    arm_group = arm.get_planning_component("ur_manipulator")
    
    # 3. è¿æ¥å¤¹çˆª
    gripper = GripperController('/gripper_controller/command')
    
    # 4. åˆå§‹åŒ–ä¼ æ„Ÿå™¨
    camera = CameraSubscriber('/camera/color/image_raw')
    depth_camera = DepthSubscriber('/camera/depth/points')
    force_sensor = ForceSensor('/wrench')
    
    # 5. å›åˆ° Home ä½ç½®
    arm_group.set_goal_state(configuration_name="home")
    arm_group.plan()
    arm_group.execute()
    
    # 6. æ‰“å¼€å¤¹çˆª
    gripper.open()
    
    return node, arm, gripper, camera, depth_camera, force_sensor
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] æ‰€æœ‰è¯é¢˜æ­£å¸¸å‘å¸ƒï¼ˆ`ros2 topic list`ï¼‰
- [ ] æœºæ¢°è‡‚èƒ½å“åº”æŒ‡ä»¤
- [ ] ç›¸æœºå›¾åƒæ¸…æ™°
- [ ] æ— é”™è¯¯æ—¥å¿—

---

#### èŠ‚ç‚¹ 2ï¼šåœºæ™¯æ„ŸçŸ¥ï¼ˆ0.1-1 ç§’ï¼‰

**2.1 æ•°æ®é‡‡é›†**

```python
def acquire_sensor_data():
    # é‡‡é›† RGB å›¾åƒ
    rgb_image = camera.get_latest_image()  # 640Ã—480Ã—3
    
    # é‡‡é›†æ·±åº¦å›¾/ç‚¹äº‘
    depth_image = depth_camera.get_depth_image()  # 640Ã—480
    point_cloud = depth_camera.get_point_cloud()  # NÃ—3
    
    return rgb_image, depth_image, point_cloud
```

**2.2 é¢„å¤„ç†**

```python
def preprocess_data(rgb, depth, cloud):
    # RGB é¢„å¤„ç†
    rgb = cv2.GaussianBlur(rgb, (5, 5), 0)  # é™å™ª
    rgb = cv2.resize(rgb, (640, 480))  # æ ‡å‡†åŒ–å°ºå¯¸
    
    # ç‚¹äº‘é¢„å¤„ç†
    cloud = voxel_grid_downsample(cloud, voxel_size=0.005)  # é™é‡‡æ ·
    cloud = passthrough_filter(cloud, axis='z', limits=[0.3, 1.0])  # è£å‰ª
    cloud = remove_outliers(cloud, nb_neighbors=20, std_ratio=2.0)  # å»å™ª
    
    return rgb, depth, cloud
```

**2.3 ç›®æ ‡æ£€æµ‹**

```python
def detect_objects_2d(rgb_image):
    # YOLO v8 æ£€æµ‹
    results = yolo_model(rgb_image)
    
    detections = []
    for result in results:
        for box in result.boxes:
            detection = {
                'class': box.cls,
                'confidence': box.conf,
                'bbox': box.xyxy,  # [x1, y1, x2, y2]
                'center': [(box.xyxy[0] + box.xyxy[2])/2,
                          (box.xyxy[1] + box.xyxy[3])/2]
            }
            detections.append(detection)
    
    return detections

def segment_objects_3d(point_cloud):
    # å¹³é¢æå–ï¼ˆæ¡Œé¢ï¼‰
    plane_model, inliers = ransac_plane_fit(point_cloud)
    plane_cloud = point_cloud[inliers]
    object_cloud = point_cloud[~inliers]
    
    # æ¬§å¼èšç±»ï¼ˆåˆ†ç¦»ç‰©ä½“ï¼‰
    clusters = euclidean_clustering(object_cloud, 
                                   tolerance=0.02, 
                                   min_size=100, 
                                   max_size=10000)
    
    objects = []
    for cluster in clusters:
        obj = {
            'cloud': cluster,
            'centroid': np.mean(cluster, axis=0),
            'bbox': compute_3d_bbox(cluster)
        }
        objects.append(obj)
    
    return objects
```

---

#### èŠ‚ç‚¹ 3ï¼šä½å§¿ä¼°è®¡ï¼ˆ0.2-2 ç§’ï¼‰

**3.1 ç²—å®šä½ï¼ˆ2D â†’ 3D æ˜ å°„ï¼‰**

```python
def coarse_localization(detection_2d, objects_3d, camera_intrinsics):
    """å°† 2D æ£€æµ‹æ˜ å°„åˆ° 3D ç‚¹äº‘å¯¹è±¡"""
    
    # è®¡ç®— 2D æ£€æµ‹æ¡†ä¸­å¿ƒåœ¨å›¾åƒä¸­çš„åƒç´ åæ ‡
    u, v = detection_2d['center']
    
    # æ‰¾åˆ°æœ€è¿‘çš„ 3D èšç±»
    min_distance = float('inf')
    matched_object = None
    
    for obj in objects_3d:
        # å°† 3D ç‚¹äº‘ä¸­å¿ƒæŠ•å½±åˆ° 2D
        obj_center_3d = obj['centroid']
        obj_center_2d = project_3d_to_2d(obj_center_3d, camera_intrinsics)
        
        # è®¡ç®—è·ç¦»
        distance = np.linalg.norm([u - obj_center_2d[0], v - obj_center_2d[1]])
        
        if distance < min_distance:
            min_distance = distance
            matched_object = obj
    
    return matched_object
```

**3.2 ç²¾ç»†é…å‡†ï¼ˆICPï¼‰**

```python
def fine_registration(target_cloud, source_model, initial_transform):
    """ä½¿ç”¨ ICP ç²¾ç¡®é…å‡†"""
    
    # é…ç½® ICP
    icp = o3d.pipelines.registration.registration_icp(
        source=source_model,  # CAD æ¨¡å‹ç‚¹äº‘
        target=target_cloud,  # åœºæ™¯ç‚¹äº‘
        max_correspondence_distance=0.01,
        init=initial_transform,
        estimation_method=o3d.pipelines.registration.TransformationEstimationPointToPoint(),
        criteria=o3d.pipelines.registration.ICPConvergenceCriteria(
            max_iteration=100
        )
    )
    
    # æå–ä½å§¿
    transformation = icp.transformation
    
    # è½¬æ¢ä¸ºä½ç½® + å››å…ƒæ•°
    position = transformation[:3, 3]
    rotation_matrix = transformation[:3, :3]
    quaternion = rotation_matrix_to_quaternion(rotation_matrix)
    
    pose = {
        'position': position,  # [x, y, z]
        'orientation': quaternion,  # [qx, qy, qz, qw]
        'fitness': icp.fitness,  # é…å‡†è´¨é‡
        'inlier_rmse': icp.inlier_rmse  # å†…ç‚¹å‡æ–¹æ ¹è¯¯å·®
    }
    
    return pose
```

**3.3 ä½å§¿ä¼˜åŒ–ï¼ˆå¡å°”æ›¼æ»¤æ³¢ï¼‰**

```python
class PoseTracker:
    """ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢è·Ÿè¸ªç‰©ä½“ä½å§¿"""
    
    def __init__(self):
        # çŠ¶æ€å‘é‡ï¼š[x, y, z, qx, qy, qz, qw, vx, vy, vz]
        self.state = np.zeros(10)
        
        # çŠ¶æ€åæ–¹å·®
        self.P = np.eye(10) * 0.1
        
        # è¿‡ç¨‹å™ªå£°
        self.Q = np.eye(10) * 0.01
        
        # æµ‹é‡å™ªå£°
        self.R = np.eye(7) * 0.005  # ä½ç½® + å§¿æ€
    
    def predict(self, dt):
        """é¢„æµ‹ä¸‹ä¸€æ—¶åˆ»çŠ¶æ€"""
        # çŠ¶æ€è½¬ç§»çŸ©é˜µï¼ˆåŒ€é€Ÿè¿åŠ¨æ¨¡å‹ï¼‰
        F = np.eye(10)
        F[0, 7] = dt  # x = x + vx * dt
        F[1, 8] = dt
        F[2, 9] = dt
        
        # é¢„æµ‹
        self.state = F @ self.state
        self.P = F @ self.P @ F.T + self.Q
    
    def update(self, measurement):
        """ç”¨æ–°æµ‹é‡æ›´æ–°çŠ¶æ€"""
        # æµ‹é‡çŸ©é˜µ
        H = np.zeros((7, 10))
        H[:7, :7] = np.eye(7)  # åªæµ‹é‡ä½ç½®å’Œå§¿æ€
        
        # å¡å°”æ›¼å¢ç›Š
        S = H @ self.P @ H.T + self.R
        K = self.P @ H.T @ np.linalg.inv(S)
        
        # æ›´æ–°
        innovation = measurement - H @ self.state
        self.state = self.state + K @ innovation
        self.P = (np.eye(10) - K @ H) @ self.P
        
        return self.state[:7]  # è¿”å›ä¼˜åŒ–åçš„ä½å§¿
```

---

#### èŠ‚ç‚¹ 4ï¼šæŠ“å–è§„åˆ’ï¼ˆ0.1-5 ç§’ï¼‰

**4.1 ç”Ÿæˆå€™é€‰æŠ“å–ç‚¹ï¼ˆé‡‡æ ·æ–¹æ³•ï¼‰**

```python
def generate_grasp_candidates(object_cloud, num_samples=50):
    """åœ¨ç‰©ä½“è¡¨é¢é‡‡æ ·å€™é€‰æŠ“å–ç‚¹"""
    
    candidates = []
    
    for i in range(num_samples):
        # éšæœºé€‰æ‹©ä¸€ä¸ªç‚¹
        point_idx = np.random.randint(len(object_cloud))
        grasp_point = object_cloud[point_idx]
        
        # è®¡ç®—å±€éƒ¨æ³•å‘é‡
        normal = estimate_normal(object_cloud, point_idx, radius=0.01)
        
        # ç”ŸæˆæŠ“å–å§¿æ€ï¼ˆæ³•å‘é‡ä¸ºæ¥è¿‘æ–¹å‘ï¼‰
        approach_vector = -normal  # æ²¿æ³•å‘é‡åæ–¹å‘æ¥è¿‘
        
        # ç”Ÿæˆæ—‹è½¬çŸ©é˜µ
        rotation = compute_rotation_from_vectors(approach_vector)
        
        # éšæœºæ—‹è½¬è§’åº¦ï¼ˆç»•æ¥è¿‘è½´ï¼‰
        angle = np.random.uniform(0, 2*np.pi)
        rotation = rotate_around_axis(rotation, approach_vector, angle)
        
        candidate = {
            'position': grasp_point,
            'orientation': rotation_matrix_to_quaternion(rotation),
            'approach_vector': approach_vector,
            'width': 0.08  # å¤¹çˆªå®½åº¦ï¼ˆæ ¹æ®ç‰©ä½“è°ƒæ•´ï¼‰
        }
        
        candidates.append(candidate)
    
    return candidates
```

**4.2 æŠ“å–è´¨é‡è¯„ä¼°**

```python
def evaluate_grasp_quality(grasp, object_cloud, arm_group):
    """è¯„ä¼°æŠ“å–è´¨é‡ï¼ˆ0-1 åˆ†æ•°ï¼‰"""
    
    score = 0.0
    weights = {'reachability': 0.3, 'collision': 0.3, 
               'stability': 0.2, 'alignment': 0.2}
    
    # 1. å¯è¾¾æ€§æ£€æŸ¥ï¼ˆIK æ˜¯å¦æœ‰è§£ï¼‰
    target_pose = create_pose_stamped(grasp['position'], grasp['orientation'])
    arm_group.set_goal_state(pose_stamped_msg=target_pose, pose_link="tool0")
    plan_result = arm_group.plan()
    
    if plan_result:
        score += weights['reachability']
    else:
        return 0.0  # IK æ— è§£ï¼Œç›´æ¥æ·˜æ±°
    
    # 2. ç¢°æ’æ£€æµ‹
    collision_free = check_collision_free(grasp, object_cloud)
    if collision_free:
        score += weights['collision']
    
    # 3. ç¨³å®šæ€§è¯„ä¼°ï¼ˆåŠ›å°é—­ï¼‰
    stability = estimate_force_closure(grasp, object_cloud)
    score += weights['stability'] * stability
    
    # 4. å¯¹é½åº¦è¯„ä¼°ï¼ˆä¸ä¸»è½´å¯¹é½æ›´å¥½ï¼‰
    alignment = compute_alignment_score(grasp, object_cloud)
    score += weights['alignment'] * alignment
    
    return score
```

**4.3 é€‰æ‹©æœ€ä¼˜æŠ“å–**

```python
def select_best_grasp(candidates, object_cloud, arm_group):
    """é€‰æ‹©è¯„åˆ†æœ€é«˜çš„æŠ“å–"""
    
    scored_grasps = []
    
    for grasp in candidates:
        score = evaluate_grasp_quality(grasp, object_cloud, arm_group)
        scored_grasps.append((score, grasp))
    
    # æŒ‰åˆ†æ•°æ’åº
    scored_grasps.sort(key=lambda x: x[0], reverse=True)
    
    # é€‰æ‹© Top-1
    if scored_grasps[0][0] > 0.5:  # é˜ˆå€¼ï¼šè‡³å°‘ 0.5 åˆ†
        return scored_grasps[0][1]
    else:
        return None  # æ— åˆé€‚æŠ“å–
```

---

#### èŠ‚ç‚¹ 5ï¼šè¿åŠ¨è§„åˆ’ï¼ˆ1-5 ç§’ï¼‰

**5.1 é¢„æŠ“å–ä½ç½®è§„åˆ’**

```python
def plan_to_pre_grasp(arm_group, grasp_pose, pre_grasp_distance=0.1):
    """è§„åˆ’åˆ°é¢„æŠ“å–ä½ç½®ï¼ˆç‰©ä½“ä¸Šæ–¹ï¼‰"""
    
    # è®¡ç®—é¢„æŠ“å–ä½å§¿ï¼ˆæ²¿æ¥è¿‘æ–¹å‘åé€€ 10cmï¼‰
    approach_vector = grasp_pose['approach_vector']
    pre_grasp_position = (grasp_pose['position'] - 
                         pre_grasp_distance * approach_vector)
    
    pre_grasp_pose = create_pose_stamped(
        pre_grasp_position, 
        grasp_pose['orientation']
    )
    
    # ä½¿ç”¨ RRT-Connect è§„åˆ’
    arm_group.set_goal_state(pose_stamped_msg=pre_grasp_pose, pose_link="tool0")
    arm_group.set_planning_pipeline_id("ompl")
    arm_group.set_planner_id("RRTConnect")
    
    plan_result = arm_group.plan()
    
    return plan_result
```

**5.2 ç¬›å¡å°”ç›´çº¿æ¥è¿‘**

```python
def plan_approach_motion(arm_group, current_pose, grasp_pose):
    """ç¬›å¡å°”ç©ºé—´ç›´çº¿è¿åŠ¨"""
    
    # ç”Ÿæˆè·¯å¾„ç‚¹
    waypoints = []
    
    # å½“å‰ä½ç½®
    waypoints.append(current_pose)
    
    # ç›®æ ‡ä½ç½®ï¼ˆåˆ† 5 ä¸ªæ’å€¼ç‚¹ï¼‰
    for i in range(1, 6):
        alpha = i / 5.0
        intermediate_pose = interpolate_pose(current_pose, grasp_pose, alpha)
        waypoints.append(intermediate_pose)
    
    # è®¡ç®—ç¬›å¡å°”è·¯å¾„
    (plan, fraction) = arm_group.compute_cartesian_path(
        waypoints,
        eef_step=0.01,  # 1cm æ­¥é•¿
        jump_threshold=0.0
    )
    
    if fraction > 0.95:  # è‡³å°‘å®Œæˆ 95% çš„è·¯å¾„
        return plan
    else:
        return None  # è§„åˆ’å¤±è´¥
```

---

#### èŠ‚ç‚¹ 6ï¼šè½¨è¿¹æ‰§è¡Œï¼ˆ5-15 ç§’ï¼‰

**6.1 æ‰§è¡Œè¿åŠ¨**

```python
def execute_pick_and_place(arm_group, gripper, grasp_pose, place_pose):
    """å®Œæ•´æ‰§è¡Œæ‹¾å–æ”¾ç½®æµç¨‹"""
    
    # é˜¶æ®µ 1ï¼šç§»åŠ¨åˆ°é¢„æŠ“å–
    logger.info("Phase 1: Moving to pre-grasp")
    plan = plan_to_pre_grasp(arm_group, grasp_pose)
    arm_group.execute(plan)
    time.sleep(0.5)
    
    # é˜¶æ®µ 2ï¼šæ‰“å¼€å¤¹çˆª
    logger.info("Phase 2: Opening gripper")
    gripper.open()
    time.sleep(1.0)
    
    # é˜¶æ®µ 3ï¼šæ¥è¿‘æŠ“å–ç‚¹
    logger.info("Phase 3: Approaching grasp point")
    current_pose = arm_group.get_current_pose()
    plan = plan_approach_motion(arm_group, current_pose, grasp_pose)
    arm_group.execute(plan)
    time.sleep(0.5)
    
    # é˜¶æ®µ 4ï¼šé—­åˆå¤¹çˆª
    logger.info("Phase 4: Closing gripper")
    gripper.close()
    time.sleep(1.0)
    
    # é˜¶æ®µ 5ï¼šéªŒè¯æŠ“å–
    logger.info("Phase 5: Verifying grasp")
    grasp_success = verify_grasp(force_sensor, threshold=5.0)
    
    if not grasp_success:
        logger.error("Grasp failed! No contact detected.")
        return False
    
    # é˜¶æ®µ 6ï¼šæŠ¬èµ·ç‰©ä½“
    logger.info("Phase 6: Lifting object")
    lift_pose = grasp_pose.copy()
    lift_pose['position'][2] += 0.1  # Z è½´ä¸Šå‡ 10cm
    plan = plan_cartesian_motion(arm_group, lift_pose)
    arm_group.execute(plan)
    time.sleep(0.5)
    
    # é˜¶æ®µ 7ï¼šç§»åŠ¨åˆ°æ”¾ç½®ä½ç½®ä¸Šæ–¹
    logger.info("Phase 7: Moving to place location")
    pre_place_pose = place_pose.copy()
    pre_place_pose['position'][2] += 0.1
    plan = plan_to_pose(arm_group, pre_place_pose)
    arm_group.execute(plan)
    time.sleep(0.5)
    
    # é˜¶æ®µ 8ï¼šä¸‹é™åˆ°æ”¾ç½®é«˜åº¦
    logger.info("Phase 8: Descending to place")
    plan = plan_cartesian_motion(arm_group, place_pose)
    arm_group.execute(plan)
    time.sleep(0.5)
    
    # é˜¶æ®µ 9ï¼šæ‰“å¼€å¤¹çˆªï¼ˆé‡Šæ”¾ï¼‰
    logger.info("Phase 9: Releasing object")
    gripper.open()
    time.sleep(1.0)
    
    # é˜¶æ®µ 10ï¼šæ’¤å›
    logger.info("Phase 10: Retracting")
    retract_pose = place_pose.copy()
    retract_pose['position'][2] += 0.1
    plan = plan_cartesian_motion(arm_group, retract_pose)
    arm_group.execute(plan)
    
    logger.info("Pick and place completed successfully!")
    return True
```

**6.2 åŠ›æ§åˆ¶æŠ“å–**

```python
def grasp_with_force_control(gripper, force_sensor, target_force=10.0):
    """åŸºäºåŠ›åé¦ˆçš„è‡ªé€‚åº”æŠ“å–"""
    
    # å‚æ•°
    force_tolerance = 2.0  # Â±2N
    max_iterations = 20
    dt = 0.05  # 50ms æ§åˆ¶å‘¨æœŸ
    
    # PID å‚æ•°
    Kp = 0.1
    Ki = 0.01
    Kd = 0.05
    
    error_sum = 0.0
    last_error = 0.0
    
    for i in range(max_iterations):
        # è¯»å–å½“å‰åŠ›
        current_force = force_sensor.get_force_magnitude()
        
        # è®¡ç®—è¯¯å·®
        error = target_force - current_force
        error_sum += error * dt
        error_derivative = (error - last_error) / dt
        
        # PID æ§åˆ¶
        control_output = Kp * error + Ki * error_sum + Kd * error_derivative
        
        # è½¬æ¢ä¸ºå¤¹çˆªä½ç½®æŒ‡ä»¤
        gripper_position = gripper.get_current_position() + control_output * 0.01
        gripper_position = np.clip(gripper_position, 0.0, 0.085)  # 0-85mm
        
        # å‘é€æŒ‡ä»¤
        gripper.set_position(gripper_position)
        
        # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡
        if abs(error) < force_tolerance:
            logger.info(f"Target force reached: {current_force:.2f} N")
            return True
        
        last_error = error
        time.sleep(dt)
    
    logger.warning("Force control timeout")
    return False
```

---

#### èŠ‚ç‚¹ 7ï¼šç»“æœéªŒè¯ï¼ˆ0.1-1 ç§’ï¼‰

```python
def verify_pick_and_place(camera, expected_position, tolerance=0.01):
    """éªŒè¯ç‰©ä½“æ˜¯å¦åœ¨ç›®æ ‡ä½ç½®"""
    
    # é‡‡é›†æ–°å›¾åƒ
    rgb_image = camera.get_latest_image()
    
    # æ£€æµ‹ç‰©ä½“
    detections = detect_objects_2d(rgb_image)
    
    if len(detections) == 0:
        logger.error("No object detected in verification")
        return False
    
    # è®¡ç®—ä½ç½®è¯¯å·®
    detected_position = detections[0]['center_3d']
    error = np.linalg.norm(detected_position - expected_position)
    
    if error < tolerance:
        logger.info(f"Verification passed! Error: {error*1000:.2f} mm")
        return True
    else:
        logger.warning(f"Verification failed! Error: {error*1000:.2f} mm")
        return False
```

---

## 4. è§†è§‰æ„ŸçŸ¥æ¨¡å—

### 4.1 2D è§†è§‰å¤„ç†æµç¨‹

#### ç‰©ä½“æ£€æµ‹ï¼ˆYOLO v8ï¼‰

**å®Œæ•´ä»£ç ç¤ºä¾‹**ï¼š

```python
from ultralytics import YOLO
import cv2

class ObjectDetector:
    def __init__(self, model_path='yolov8n.pt', confidence_threshold=0.5):
        self.model = YOLO(model_path)
        self.conf_threshold = confidence_threshold
        
        # ç±»åˆ«åç§°ï¼ˆæ ¹æ®è®­ç»ƒæ•°æ®é›†ï¼‰
        self.class_names = ['chip', 'pcb', 'connector', 'cable']
    
    def detect(self, image):
        """
        æ£€æµ‹å›¾åƒä¸­çš„ç‰©ä½“
        
        Args:
            image: numpy array, shape (H, W, 3), BGR format
        
        Returns:
            detections: list of dict, æ¯ä¸ªæ£€æµ‹åŒ…å«:
                - class_id: int
                - class_name: str
                - confidence: float
                - bbox: [x1, y1, x2, y2]
                - center: [cx, cy]
        """
        # æ¨ç†
        results = self.model(image, conf=self.conf_threshold)
        
        detections = []
        
        for result in results:
            boxes = result.boxes
            
            for box in boxes:
                class_id = int(box.cls[0])
                confidence = float(box.conf[0])
                bbox = box.xyxy[0].cpu().numpy()  # [x1, y1, x2, y2]
                
                # è®¡ç®—ä¸­å¿ƒç‚¹
                center_x = (bbox[0] + bbox[2]) / 2
                center_y = (bbox[1] + bbox[3]) / 2
                
                detection = {
                    'class_id': class_id,
                    'class_name': self.class_names[class_id],
                    'confidence': confidence,
                    'bbox': bbox,
                    'center': [center_x, center_y]
                }
                
                detections.append(detection)
        
        return detections
    
    def visualize(self, image, detections):
        """å¯è§†åŒ–æ£€æµ‹ç»“æœ"""
        vis_image = image.copy()
        
        for det in detections:
            bbox = det['bbox'].astype(int)
            label = f"{det['class_name']} {det['confidence']:.2f}"
            
            # ç»˜åˆ¶è¾¹ç•Œæ¡†
            cv2.rectangle(vis_image, 
                         (bbox[0], bbox[1]), 
                         (bbox[2], bbox[3]), 
                         (0, 255, 0), 2)
            
            # ç»˜åˆ¶æ ‡ç­¾
            cv2.putText(vis_image, label, 
                       (bbox[0], bbox[1] - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 
                       0.5, (0, 255, 0), 2)
            
            # ç»˜åˆ¶ä¸­å¿ƒç‚¹
            center = tuple(map(int, det['center']))
            cv2.circle(vis_image, center, 5, (0, 0, 255), -1)
        
        return vis_image
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```python
# åˆå§‹åŒ–æ£€æµ‹å™¨
detector = ObjectDetector(model_path='custom_yolov8_3c.pt')

# è®¢é˜…ç›¸æœºè¯é¢˜
image_sub = node.create_subscription(
    Image,
    '/camera/color/image_raw',
    lambda msg: detector.detect(bridge.imgmsg_to_cv2(msg)),
    10
)
```

---

### 4.2 3D è§†è§‰å¤„ç†æµç¨‹

#### ç‚¹äº‘åˆ†å‰²ä¸èšç±»

```python
import open3d as o3d
import numpy as np

class PointCloudProcessor:
    def __init__(self):
        self.voxel_size = 0.005  # 5mm ä½“ç´ 
        self.plane_threshold = 0.01  # 1cm å¹³é¢é˜ˆå€¼
        self.cluster_tolerance = 0.02  # 2cm èšç±»è·ç¦»
    
    def preprocess(self, point_cloud):
        """é¢„å¤„ç†ç‚¹äº‘"""
        # 1. é™é‡‡æ ·
        cloud_down = point_cloud.voxel_down_sample(self.voxel_size)
        
        # 2. å»é™¤ç¦»ç¾¤ç‚¹
        cloud_filtered, _ = cloud_down.remove_statistical_outlier(
            nb_neighbors=20,
            std_ratio=2.0
        )
        
        # 3. ä¼°è®¡æ³•å‘é‡
        cloud_filtered.estimate_normals(
            search_param=o3d.geometry.KDTreeSearchParamHybrid(
                radius=0.01, max_nn=30
            )
        )
        
        return cloud_filtered
    
    def segment_plane(self, point_cloud):
        """æå–æ¡Œé¢å¹³é¢"""
        plane_model, inliers = point_cloud.segment_plane(
            distance_threshold=self.plane_threshold,
            ransac_n=3,
            num_iterations=1000
        )
        
        # åˆ†ç¦»å¹³é¢å’Œç‰©ä½“ç‚¹äº‘
        plane_cloud = point_cloud.select_by_index(inliers)
        object_cloud = point_cloud.select_by_index(inliers, invert=True)
        
        return plane_cloud, object_cloud, plane_model
    
    def cluster_objects(self, point_cloud):
        """æ¬§å¼èšç±»åˆ†ç¦»ç‰©ä½“"""
        # è½¬æ¢ä¸º numpy è¿›è¡Œèšç±»
        points = np.asarray(point_cloud.points)
        
        # ä½¿ç”¨ DBSCAN èšç±»
        labels = np.array(
            point_cloud.cluster_dbscan(
                eps=self.cluster_tolerance,
                min_points=10
            )
        )
        
        # æå–æ¯ä¸ªèšç±»
        max_label = labels.max()
        clusters = []
        
        for i in range(max_label + 1):
            cluster_indices = np.where(labels == i)[0]
            
            if len(cluster_indices) > 50:  # è‡³å°‘ 50 ä¸ªç‚¹
                cluster_cloud = point_cloud.select_by_index(cluster_indices)
                clusters.append(cluster_cloud)
        
        return clusters
    
    def compute_object_features(self, cluster):
        """è®¡ç®—ç‰©ä½“ç‰¹å¾"""
        points = np.asarray(cluster.points)
        
        features = {
            'centroid': np.mean(points, axis=0),
            'bbox_min': np.min(points, axis=0),
            'bbox_max': np.max(points, axis=0),
            'num_points': len(points),
            'volume': self.compute_convex_hull_volume(cluster)
        }
        
        # è®¡ç®—ä¸»è½´æ–¹å‘ï¼ˆPCAï¼‰
        pca = o3d.geometry.PointCloud.get_oriented_bounding_box(cluster)
        features['orientation'] = pca.R  # æ—‹è½¬çŸ©é˜µ
        
        return features
    
    def compute_convex_hull_volume(self, cluster):
        """è®¡ç®—å‡¸åŒ…ä½“ç§¯"""
        hull, _ = cluster.compute_convex_hull()
        volume = hull.get_volume()
        return volume
```

---

## 5. ä½å§¿ä¼°è®¡ä¸ä¼˜åŒ–

### 5.1 ICP é…å‡†è¯¦è§£

```python
class ICPPoseEstimator:
    def __init__(self, model_path):
        # åŠ è½½ CAD æ¨¡å‹ç‚¹äº‘
        self.model_cloud = o3d.io.read_point_cloud(model_path)
        self.model_cloud = self.preprocess_model(self.model_cloud)
    
    def preprocess_model(self, cloud):
        """é¢„å¤„ç†æ¨¡å‹ç‚¹äº‘"""
        # é™é‡‡æ ·
        cloud_down = cloud.voxel_down_sample(0.002)
        
        # è®¡ç®—æ³•å‘é‡
        cloud_down.estimate_normals()
        
        # è®¡ç®— FPFH ç‰¹å¾
        fpfh = o3d.pipelines.registration.compute_fpfh_feature(
            cloud_down,
            o3d.geometry.KDTreeSearchParamHybrid(radius=0.01, max_nn=100)
        )
        
        return cloud_down, fpfh
    
    def estimate_pose(self, scene_cloud, initial_guess=None):
        """ä¼°è®¡ç‰©ä½“ä½å§¿"""
        
        # é¢„å¤„ç†åœºæ™¯ç‚¹äº‘
        scene_down, scene_fpfh = self.preprocess_model(scene_cloud)
        
        # å¦‚æœæ²¡æœ‰åˆå§‹çŒœæµ‹ï¼Œè¿›è¡Œå…¨å±€é…å‡†
        if initial_guess is None:
            initial_guess = self.global_registration(
                self.model_cloud[0], scene_down,
                self.model_cloud[1], scene_fpfh
            )
        
        # ç²¾ç»†é…å‡†ï¼ˆICPï¼‰
        result = o3d.pipelines.registration.registration_icp(
            self.model_cloud[0], scene_down,
            max_correspondence_distance=0.01,
            init=initial_guess,
            estimation_method=o3d.pipelines.registration.TransformationEstimationPointToPlane(),
            criteria=o3d.pipelines.registration.ICPConvergenceCriteria(
                max_iteration=100
            )
        )
        
        # æå–ä½å§¿
        T = result.transformation
        position = T[:3, 3]
        rotation = T[:3, :3]
        
        pose = {
            'position': position,
            'rotation_matrix': rotation,
            'quaternion': self.rotation_to_quaternion(rotation),
            'fitness': result.fitness,
            'rmse': result.inlier_rmse
        }
        
        return pose
    
    def global_registration(self, source, target, source_fpfh, target_fpfh):
        """å…¨å±€é…å‡†ï¼ˆRANSACï¼‰"""
        result = o3d.pipelines.registration.registration_ransac_based_on_feature_matching(
            source, target,
            source_fpfh, target_fpfh,
            mutual_filter=True,
            max_correspondence_distance=0.05,
            estimation_method=o3d.pipelines.registration.TransformationEstimationPointToPoint(),
            ransac_n=4,
            checkers=[
                o3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength(0.9),
                o3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance(0.05)
            ],
            criteria=o3d.pipelines.registration.RANSACConvergenceCriteria(
                max_iteration=4000000,
                confidence=0.999
            )
        )
        
        return result.transformation
```

---

### 5.2 æ·±åº¦å­¦ä¹ ä½å§¿ä¼°è®¡ï¼ˆFoundationPoseï¼‰

```python
import torch
from foundation_pose import FoundationPose

class DLPoseEstimator:
    def __init__(self, model_path, device='cuda'):
        self.model = FoundationPose(model_path)
        self.model.to(device)
        self.model.eval()
        self.device = device
    
    def estimate_pose(self, rgb_image, depth_image, object_mask, intrinsics):
        """
        ä½¿ç”¨æ·±åº¦å­¦ä¹ ä¼°è®¡ 6D ä½å§¿
        
        Args:
            rgb_image: (H, W, 3)
            depth_image: (H, W)
            object_mask: (H, W), binary mask
            intrinsics: camera intrinsic matrix
        
        Returns:
            pose: dict with 'position' and 'quaternion'
        """
        # é¢„å¤„ç†
        rgb_tensor = torch.from_numpy(rgb_image).permute(2, 0, 1).float() / 255.0
        depth_tensor = torch.from_numpy(depth_image).float()
        mask_tensor = torch.from_numpy(object_mask).float()
        
        # æ·»åŠ  batch ç»´åº¦
        rgb_tensor = rgb_tensor.unsqueeze(0).to(self.device)
        depth_tensor = depth_tensor.unsqueeze(0).unsqueeze(0).to(self.device)
        mask_tensor = mask_tensor.unsqueeze(0).unsqueeze(0).to(self.device)
        
        # æ¨ç†
        with torch.no_grad():
            outputs = self.model(rgb_tensor, depth_tensor, mask_tensor)
        
        # è§£æè¾“å‡º
        translation = outputs['translation'][0].cpu().numpy()  # (3,)
        rotation_matrix = outputs['rotation'][0].cpu().numpy()  # (3, 3)
        confidence = outputs['confidence'][0].item()
        
        pose = {
            'position': translation,
            'rotation_matrix': rotation_matrix,
            'quaternion': self.rotation_to_quaternion(rotation_matrix),
            'confidence': confidence
        }
        
        return pose
```

---

## 6. æŠ“å–è§„åˆ’æ¨¡å—

### 6.1 GraspNet é›†æˆ

```python
from graspnetAPI import GraspNet

class GraspNetPlanner:
    def __init__(self, checkpoint_path, device='cuda'):
        self.graspnet = GraspNet(
            checkpoint_path=checkpoint_path,
            device=device
        )
    
    def plan_grasp(self, point_cloud, camera_pose, top_k=10):
        """
        ä½¿ç”¨ GraspNet è§„åˆ’æŠ“å–
        
        Args:
            point_cloud: (N, 3) numpy array
            camera_pose: (4, 4) transformation matrix
            top_k: number of top grasps to return
        
        Returns:
            grasps: list of grasp candidates
        """
        # GraspNet æ¨ç†
        gg = self.graspnet.predict(
            point_cloud,
            camera_pose,
            collision_thresh=0.01
        )
        
        # æŒ‰åˆ†æ•°æ’åº
        gg = gg.nms().sort_by_score()
        
        # æå– top-k
        grasps = []
        for i in range(min(top_k, len(gg))):
            grasp = gg[i]
            
            grasp_dict = {
                'position': grasp.translation,  # (3,)
                'rotation_matrix': grasp.rotation_matrix,  # (3, 3)
                'width': grasp.width,  # gripper width
                'depth': grasp.depth,  # grasp depth
                'score': grasp.score
            }
            
            grasps.append(grasp_dict)
        
        return grasps
```

---

## 7. è¿åŠ¨è§„åˆ’ä¸æ§åˆ¶

### 7.1 MoveIt2 é…ç½®

**moveit_config.yaml**ï¼š

```yaml
# è§„åˆ’å™¨é…ç½®
planning_pipelines:
  ompl:
    planning_plugin: ompl_interface/OMPLPlanner
    request_adapters: >-
      default_planner_request_adapters/AddTimeOptimalParameterization
      default_planner_request_adapters/FixWorkspaceBounds
      default_planner_request_adapters/FixStartStateBounds
      default_planner_request_adapters/FixStartStateCollision
      default_planner_request_adapters/FixStartStatePathConstraints
    start_state_max_bounds_error: 0.1
    
    # OMPL è§„åˆ’å™¨å‚æ•°
    planner_configs:
      RRTConnect:
        type: geometric::RRTConnect
        range: 0.0  # 0.0 means auto-detect
      
      RRTstar:
        type: geometric::RRTstar
        range: 0.0
        goal_bias: 0.05
        
      PRM:
        type: geometric::PRM
        max_nearest_neighbors: 10

  pilz_industrial_motion_planner:
    planning_plugin: pilz_industrial_motion_planner/CommandPlanner
    capabilities: >-
      pilz_industrial_motion_planner/MoveGroupSequenceAction
      pilz_industrial_motion_planner/MoveGroupSequenceService

# è¿åŠ¨å­¦æ±‚è§£å™¨
kinematics:
  ur_manipulator:
    kinematics_solver: TRAC-IK
    kinematics_solver_search_resolution: 0.005
    kinematics_solver_timeout: 0.05
    kinematics_solver_attempts: 3

# æ§åˆ¶å™¨
trajectory_execution:
  allowed_execution_duration_scaling: 1.2
  allowed_goal_duration_margin: 0.5
  allowed_start_tolerance: 0.01
```

---

### 7.2 ros2_control é…ç½®

**controller.yaml**ï¼š

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    
    # æ§åˆ¶å™¨åˆ—è¡¨
    joint_trajectory_controller:
      type: joint_trajectory_controller/JointTrajectoryController
    
    gripper_controller:
      type: position_controllers/GripperActionController

# å…³èŠ‚è½¨è¿¹æ§åˆ¶å™¨
joint_trajectory_controller:
  ros__parameters:
    joints:
      - shoulder_pan_joint
      - shoulder_lift_joint
      - elbow_joint
      - wrist_1_joint
      - wrist_2_joint
      - wrist_3_joint
    
    command_interfaces:
      - position
    
    state_interfaces:
      - position
      - velocity
    
    state_publish_rate: 50.0
    action_monitor_rate: 20.0
    
    constraints:
      stopped_velocity_tolerance: 0.01
      goal_time: 0.6
      shoulder_pan_joint:
        trajectory: 0.05
        goal: 0.01
      shoulder_lift_joint:
        trajectory: 0.05
        goal: 0.01
      # ... å…¶ä»–å…³èŠ‚

# å¤¹çˆªæ§åˆ¶å™¨
gripper_controller:
  ros__parameters:
    joint: robotiq_85_left_knuckle_joint
    action_monitor_rate: 20.0
    goal_tolerance: 0.01
    max_effort: 100.0
    allow_stalling: true
    stall_velocity_threshold: 0.001
    stall_timeout: 1.0
```

---

## 8. æ‰§è¡Œä¸åé¦ˆ

### 8.1 æ‰§è¡ŒçŠ¶æ€æœº

```python
from enum import Enum

class GraspState(Enum):
    IDLE = 0
    SENSING = 1
    PLANNING_GRASP = 2
    PLANNING_MOTION = 3
    EXECUTING = 4
    VERIFYING = 5
    SUCCESS = 6
    FAILED = 7

class GraspStateMachine:
    def __init__(self):
        self.state = GraspState.IDLE
        self.error_count = 0
        self.max_retries = 3
    
    def run(self, perception, planner, executor):
        """æ‰§è¡ŒæŠ“å–çŠ¶æ€æœº"""
        
        while self.state != GraspState.SUCCESS:
            if self.state == GraspState.IDLE:
                self.state = GraspState.SENSING
                logger.info("State: IDLE -> SENSING")
            
            elif self.state == GraspState.SENSING:
                # æ„ŸçŸ¥åœºæ™¯
                objects = perception.detect_objects()
                
                if len(objects) > 0:
                    self.target_object = objects[0]
                    self.state = GraspState.PLANNING_GRASP
                    logger.info("State: SENSING -> PLANNING_GRASP")
                else:
                    logger.error("No objects detected")
                    self.state = GraspState.FAILED
            
            elif self.state == GraspState.PLANNING_GRASP:
                # è§„åˆ’æŠ“å–
                grasp = planner.plan_grasp(self.target_object)
                
                if grasp is not None:
                    self.grasp_plan = grasp
                    self.state = GraspState.PLANNING_MOTION
                    logger.info("State: PLANNING_GRASP -> PLANNING_MOTION")
                else:
                    logger.error("Grasp planning failed")
                    self.handle_failure()
            
            elif self.state == GraspState.PLANNING_MOTION:
                # è§„åˆ’è¿åŠ¨
                trajectory = planner.plan_motion(self.grasp_plan)
                
                if trajectory is not None:
                    self.trajectory = trajectory
                    self.state = GraspState.EXECUTING
                    logger.info("State: PLANNING_MOTION -> EXECUTING")
                else:
                    logger.error("Motion planning failed")
                    self.handle_failure()
            
            elif self.state == GraspState.EXECUTING:
                # æ‰§è¡Œ
                success = executor.execute(self.trajectory, self.grasp_plan)
                
                if success:
                    self.state = GraspState.VERIFYING
                    logger.info("State: EXECUTING -> VERIFYING")
                else:
                    logger.error("Execution failed")
                    self.handle_failure()
            
            elif self.state == GraspState.VERIFYING:
                # éªŒè¯
                success = perception.verify_grasp(self.target_object)
                
                if success:
                    self.state = GraspState.SUCCESS
                    logger.info("State: VERIFYING -> SUCCESS")
                else:
                    logger.error("Verification failed")
                    self.handle_failure()
            
            elif self.state == GraspState.FAILED:
                logger.error("Grasp failed!")
                break
        
        return self.state == GraspState.SUCCESS
    
    def handle_failure(self):
        """å¤„ç†å¤±è´¥"""
        self.error_count += 1
        
        if self.error_count < self.max_retries:
            logger.warning(f"Retry {self.error_count}/{self.max_retries}")
            self.state = GraspState.SENSING  # é‡æ–°æ„ŸçŸ¥
        else:
            logger.error("Max retries reached")
            self.state = GraspState.FAILED
```

---

## 9. æ•°æ®æµä¸é€šä¿¡

### 9.1 ROS2 è¯é¢˜æ¶æ„

```
æ„ŸçŸ¥æ¨¡å—å‘å¸ƒçš„è¯é¢˜ï¼š
/camera/color/image_raw         (sensor_msgs/Image) - RGB å›¾åƒ
/camera/depth/image_raw         (sensor_msgs/Image) - æ·±åº¦å›¾
/camera/depth/points            (sensor_msgs/PointCloud2) - ç‚¹äº‘
/detected_objects               (custom_msgs/DetectionArray) - æ£€æµ‹ç»“æœ
/object_poses                   (geometry_msgs/PoseArray) - ç‰©ä½“ä½å§¿

è§„åˆ’æ¨¡å—å‘å¸ƒçš„è¯é¢˜ï¼š
/grasp_candidates               (custom_msgs/GraspArray) - å€™é€‰æŠ“å–
/selected_grasp                 (custom_msgs/Grasp) - é€‰å®šæŠ“å–
/planned_trajectory             (trajectory_msgs/JointTrajectory) - è½¨è¿¹

æ§åˆ¶æ¨¡å—å‘å¸ƒçš„è¯é¢˜ï¼š
/joint_states                   (sensor_msgs/JointState) - å…³èŠ‚çŠ¶æ€
/wrench                         (geometry_msgs/WrenchStamped) - åŠ›/åŠ›çŸ©
/gripper_state                  (control_msgs/GripperState) - å¤¹çˆªçŠ¶æ€

æœåŠ¡æ¥å£ï¼š
/plan_grasp                     (custom_srvs/PlanGrasp) - è§„åˆ’æŠ“å–æœåŠ¡
/execute_grasp                  (custom_srvs/ExecuteGrasp) - æ‰§è¡ŒæŠ“å–æœåŠ¡

Action æ¥å£ï¼š
/pick_place                     (custom_actions/PickPlace) - æ‹¾å–æ”¾ç½®åŠ¨ä½œ
/move_to_pose                   (moveit_msgs/MoveGroupAction) - ç§»åŠ¨åŠ¨ä½œ
```

---

## 10. å…³é”®æŠ€æœ¯é€‰å‹å¯¹æ¯”

### 10.1 è§†è§‰æ£€æµ‹æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | ç²¾åº¦ | é€Ÿåº¦ | è®­ç»ƒéš¾åº¦ | æ¨èæœˆåº¦ |
|------|------|------|---------|---------|
| ArUco æ ‡è®° | Â±1mm | >100 FPS | æ— éœ€è®­ç»ƒ | æœˆåº¦ 2 |
| é¢œè‰²é˜ˆå€¼ | Â±5mm | >100 FPS | æ— éœ€è®­ç»ƒ | æœˆåº¦ 2 |
| YOLO v8 | Â±3mm | 30-60 FPS | ä¸­ç­‰ | æœˆåº¦ 3 |
| Mask R-CNN | Â±2mm | 5-10 FPS | å›°éš¾ | å¯é€‰ |

### 10.2 ä½å§¿ä¼°è®¡æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | ç²¾åº¦ | é€Ÿåº¦ | ä¾èµ– | æ¨èåœºæ™¯ |
|------|------|------|------|---------|
| ICP | Â±1mm | 1-5s | éœ€CADæ¨¡å‹ | å·²çŸ¥ç‰©ä½“ |
| PnP | Â±5mm | <10ms | ç‰¹å¾ç‚¹ | çº¹ç†ä¸°å¯Œ |
| DenseFusion | Â±5mm | 100ms | GPU | æœªçŸ¥ç‰©ä½“ |
| FoundationPose | Â±2mm | 200ms | GPU | é€šç”¨åœºæ™¯ |

### 10.3 æŠ“å–è§„åˆ’æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ³›åŒ–æ€§ | é€Ÿåº¦ | æˆåŠŸç‡ | æ¨èåœºæ™¯ |
|------|--------|------|--------|---------|
| å›ºå®šç‚¹ | å·® | å¿« | é«˜ï¼ˆå›ºå®šï¼‰ | æœˆåº¦ 1 |
| å¯å‘å¼è§„åˆ™ | ä¸­ | å¿« | ä¸­ | æœˆåº¦ 2 |
| GraspNet | å¥½ | ä¸­ | é«˜ | æœˆåº¦ 3 |
| å¼ºåŒ–å­¦ä¹  | æœ€å¥½ | æ…¢ï¼ˆè®­ç»ƒï¼‰ | é«˜ | é•¿æœŸç ”ç©¶ |

---

## æ€»ç»“

æœ¬æ–‡æ¡£ç³»ç»Ÿåœ°ä»‹ç»äº†æœºæ¢°è‡‚æŠ“å–ç³»ç»Ÿçš„å®Œæ•´æŠ€æœ¯æ¶æ„ï¼Œæ¶µç›–ï¼š

1. **åˆ†å±‚æ¶æ„**ï¼šä»ä¼ æ„Ÿå™¨åˆ°åº”ç”¨çš„ 5 å±‚ç»“æ„
2. **æŠ€æœ¯æ ˆ**ï¼š2D/3D è§†è§‰ã€ä½å§¿ä¼°è®¡ã€è¿åŠ¨è§„åˆ’ã€æ§åˆ¶çš„å®Œæ•´æŠ€æœ¯é€‰å‹
3. **è¯¦ç»†æµç¨‹**ï¼šä»æ„ŸçŸ¥åˆ°æ‰§è¡Œçš„ 8 æ­¥å®Œæ•´æµç¨‹
4. **ä»£ç æ¡†æ¶**ï¼šå…³é”®æ¨¡å—çš„ Python å®ç°ç¤ºä¾‹
5. **é€‰å‹å¯¹æ¯”**ï¼šä¸åŒæŠ€æœ¯æ–¹æ¡ˆçš„æ¨ªå‘å¯¹æ¯”

**æ ¸å¿ƒæŠ€æœ¯æ ˆæ€»ç»“**ï¼š

| å±‚æ¬¡ | æœˆåº¦ 1 | æœˆåº¦ 2 | æœˆåº¦ 3 |
|------|--------|--------|--------|
| **è§†è§‰** | æ—  | ArUco / é¢œè‰² | YOLO v8 + PCL |
| **ä½å§¿** | å›ºå®šåæ ‡ | ç®€å•å‡ ä½• | ICP / DL |
| **è§„åˆ’** | ç¡¬ç¼–ç  | å¯å‘å¼ | GraspNet |
| **æ§åˆ¶** | ä½ç½®æ§åˆ¶ | ä½ç½®æ§åˆ¶ | ä½ç½®+åŠ›æ§ |

**ä¸‹ä¸€æ­¥**ï¼šåŸºäºæœ¬æ–‡æ¡£çš„æŠ€æœ¯æ¶æ„ï¼Œç”Ÿæˆå…·ä½“çš„å®æ–½ä»£ç å’Œé…ç½®æ–‡ä»¶ã€‚

---

## ğŸ“– æœ¯è¯­è¡¨

| æœ¯è¯­ | è‹±æ–‡å…¨ç§° | ä¸­æ–‡è§£é‡Š | ç›¸å…³ç« èŠ‚ |
|------|---------|---------|---------|
| **ROS2** | Robot Operating System 2 | æœºå™¨äººæ“ä½œç³»ç»Ÿç¬¬2ç‰ˆï¼Œæä¾›ç¡¬ä»¶æŠ½è±¡ã€åº•å±‚è®¾å¤‡æ§åˆ¶ç­‰åŠŸèƒ½ | å…¨æ–‡ |
| **Gazebo** | - | å¼€æº3Dæœºå™¨äººä»¿çœŸå™¨ï¼Œæ”¯æŒç‰©ç†å¼•æ“å’Œä¼ æ„Ÿå™¨æ¨¡æ‹Ÿ | 1.2, 2.1 |
| **MoveIt2** | - | ROS2çš„è¿åŠ¨è§„åˆ’æ¡†æ¶ï¼Œæä¾›é€†è¿åŠ¨å­¦ã€è½¨è¿¹è§„åˆ’ç­‰åŠŸèƒ½ | 2.5, 7.1 |
| **YOLO** | You Only Look Once | å®æ—¶ç‰©ä½“æ£€æµ‹ç®—æ³•ï¼Œå•æ¬¡å‰å‘ä¼ æ’­å®Œæˆæ£€æµ‹ | 2.2.1, 4.1, 12.1 |
| **PCL** | Point Cloud Library | ç‚¹äº‘å¤„ç†åº“ï¼Œæä¾›æ»¤æ³¢ã€åˆ†å‰²ã€é…å‡†ç­‰ç®—æ³• | 2.2.2, 4.2 |
| **ICP** | Iterative Closest Point | è¿­ä»£æœ€è¿‘ç‚¹ç®—æ³•ï¼Œç”¨äºç‚¹äº‘é…å‡†å’Œä½å§¿ä¼°è®¡ | 2.3, 5.1 |
| **RRT** | Rapidly-exploring Random Tree | å¿«é€Ÿæ¢ç´¢éšæœºæ ‘ï¼Œç”¨äºè¿åŠ¨è§„åˆ’çš„è·¯å¾„æœç´¢ | 2.5, 7.1 |
| **OMPL** | Open Motion Planning Library | å¼€æºè¿åŠ¨è§„åˆ’åº“ï¼ŒåŒ…å«å¤šç§è§„åˆ’ç®—æ³• | 2.5 |
| **IK** | Inverse Kinematics | é€†è¿åŠ¨å­¦ï¼Œä»æœ«ç«¯ä½å§¿è®¡ç®—å…³èŠ‚è§’åº¦ | 2.5, 3.3 |
| **FK** | Forward Kinematics | æ­£è¿åŠ¨å­¦ï¼Œä»å…³èŠ‚è§’åº¦è®¡ç®—æœ«ç«¯ä½å§¿ | - |
| **DoF** | Degrees of Freedom | è‡ªç”±åº¦ï¼Œæœºæ¢°è‡‚å¯ç‹¬ç«‹è¿åŠ¨çš„å…³èŠ‚æ•°é‡ | 1.1 |
| **6D Pose** | 6-Dimensional Pose | 6ç»´ä½å§¿ï¼ŒåŒ…å«3Dä½ç½®(x,y,z)å’Œ3Då§¿æ€(roll,pitch,yaw) | 2.3, 5.1 |
| **RGB-D** | RGB-Depth | å½©è‰²å›¾åƒ+æ·±åº¦ä¿¡æ¯ï¼Œç”±RGBç›¸æœºå’Œæ·±åº¦ç›¸æœºæä¾› | 2.2.2, 4.2 |
| **F/T Sensor** | Force/Torque Sensor | åŠ›/åŠ›çŸ©ä¼ æ„Ÿå™¨ï¼Œæµ‹é‡æ¥è§¦åŠ›å’Œæ‰­çŸ© | 1.1, 3.3, 11.4 |
| **RANSAC** | Random Sample Consensus | éšæœºé‡‡æ ·ä¸€è‡´æ€§ç®—æ³•ï¼Œç”¨äºé²æ£’ä¼°è®¡æ¨¡å‹å‚æ•° | 2.2.2, 4.2 |
| **FPFH** | Fast Point Feature Histograms | å¿«é€Ÿç‚¹ç‰¹å¾ç›´æ–¹å›¾ï¼Œç”¨äºç‚¹äº‘ç‰¹å¾æè¿° | 2.2.2, 5.1 |
| **PnP** | Perspective-n-Point | é€è§†nç‚¹ç®—æ³•ï¼Œä»2D-3Då¯¹åº”å…³ç³»ä¼°è®¡ä½å§¿ | 2.3, 5.2 |
| **ToF** | Time of Flight | é£è¡Œæ—¶é—´æµ‹è·ï¼Œæ·±åº¦ç›¸æœºçš„ä¸€ç§å·¥ä½œåŸç† | 2.2.2 |
| **TensorRT** | - | NVIDIAæ·±åº¦å­¦ä¹ æ¨ç†ä¼˜åŒ–å™¨ï¼ŒåŠ é€Ÿæ¨¡å‹æ¨ç† | 2.2.1, 12.1 |
| **UR5e** | Universal Robots 5e | ä¼˜å‚²åä½œæœºå™¨äººUR5ç³»åˆ—å¢å¼ºç‰ˆ | 1.1, 6-robot-selection/ |
| **Robotiq** | - | æœºå™¨äººå¤¹çˆªåˆ¶é€ å•†ï¼Œ2F-85ä¸ºå¸¸ç”¨å¹³è¡Œå¤¹çˆª | 1.1 |
| **ArUco** | - | åŸºäºOpenCVçš„æ–¹å½¢åŸºå‡†æ ‡è®°ï¼Œç”¨äºå¿«é€Ÿå®šä½ | 2.2.1, 10.1 |
| **GraspNet** | - | åŸºäºæ·±åº¦å­¦ä¹ çš„æŠ“å–è§„åˆ’ç½‘ç»œ | 2.4, 6.1, 12.2 |
| **Dex-Net** | Dexterity Network | æŠ“å–çµå·§æ€§ç½‘ç»œï¼Œç”¨äºå¹³è¡Œå¤¹çˆªæŠ“å–è§„åˆ’ | 2.4 |
| **SE(3)** | Special Euclidean Group 3 | ç‰¹æ®Šæ¬§æ°ç¾¤ï¼Œæè¿°3Dç©ºé—´çš„åˆšä½“å˜æ¢(æ—‹è½¬+å¹³ç§») | - |
| **Jacobian** | - | é›…å¯æ¯”çŸ©é˜µï¼Œæè¿°å…³èŠ‚é€Ÿåº¦ä¸æœ«ç«¯é€Ÿåº¦çš„å…³ç³» | - |
| **Singularity** | - | å¥‡å¼‚ç‚¹ï¼Œæœºæ¢°è‡‚å¤±å»ä¸€ä¸ªæˆ–å¤šä¸ªè‡ªç”±åº¦çš„é…ç½® | 11.1 |
| **Workspace** | - | å·¥ä½œç©ºé—´ï¼Œæœºæ¢°è‡‚æœ«ç«¯å¯åˆ°è¾¾çš„3Dç©ºé—´åŒºåŸŸ | 11.4 |
| **Collision-Free** | - | æ— ç¢°æ’ï¼Œè·¯å¾„æˆ–é…ç½®ä¸ä¸ç¯å¢ƒæˆ–è‡ªèº«å‘ç”Ÿç¢°æ’ | 2.5, 3.3, 7.1 |
| **Trajectory** | - | è½¨è¿¹ï¼Œéšæ—¶é—´å˜åŒ–çš„å…³èŠ‚è§’åº¦æˆ–æœ«ç«¯ä½å§¿åºåˆ— | 2.5, 3.3 |
| **Cartesian Path** | - | ç¬›å¡å°”è·¯å¾„ï¼Œæœ«ç«¯åœ¨ç¬›å¡å°”ç©ºé—´ä¸­çš„ç›´çº¿æˆ–æ›²çº¿è¿åŠ¨ | 2.5, 3.3 |
| **PID** | Proportional-Integral-Derivative | æ¯”ä¾‹-ç§¯åˆ†-å¾®åˆ†æ§åˆ¶å™¨ï¼Œç»å…¸åé¦ˆæ§åˆ¶ç®—æ³• | 3.3 |
| **Voxel** | Volume Element | ä½“ç´ ï¼Œ3Dç©ºé—´ä¸­çš„æœ€å°å•å…ƒï¼Œç”¨äºç‚¹äº‘é™é‡‡æ · | 2.2.2, 4.2 |
| **Ground Truth** | - | çœŸå€¼ï¼Œäººå·¥æ ‡æ³¨æˆ–ç²¾ç¡®æµ‹é‡å¾—åˆ°çš„å‚è€ƒæ•°æ® | 12.1 |
| **mAP** | mean Average Precision | å¹³å‡ç²¾åº¦å‡å€¼ï¼Œç‰©ä½“æ£€æµ‹çš„è¯„ä»·æŒ‡æ ‡ | 12.1 |
| **IoU** | Intersection over Union | äº¤å¹¶æ¯”ï¼Œé¢„æµ‹æ¡†ä¸çœŸå€¼æ¡†çš„é‡å åº¦è¯„ä»·æŒ‡æ ‡ | 12.1 |
| **ROS2 Control** | - | ROS2çš„æ§åˆ¶æ¡†æ¶ï¼Œæä¾›æ§åˆ¶å™¨ç®¡ç†å’Œç¡¬ä»¶æ¥å£ | 2.6, 7.2 |
| **URDF** | Unified Robot Description Format | ç»Ÿä¸€æœºå™¨äººæè¿°æ ¼å¼ï¼ŒXMLæ ¼å¼çš„æœºå™¨äººæ¨¡å‹ | 1.1 |
| **SDF** | Simulation Description Format | ä»¿çœŸæè¿°æ ¼å¼ï¼ŒGazeboä½¿ç”¨çš„åœºæ™¯æè¿°æ–‡ä»¶ | 1.1 |
| **STOMP** | Stochastic Trajectory Optimization | éšæœºè½¨è¿¹ä¼˜åŒ–ï¼Œç”¨äºå¹³æ»‘è¿åŠ¨è§„åˆ’ç»“æœ | 2.5 |
| **CHOMP** | Covariant Hamiltonian Optimization | åå˜å“ˆå¯†é¡¿ä¼˜åŒ–ï¼Œç”¨äºè½¨è¿¹ä¼˜åŒ– | 2.5 |
| **NDT** | Normal Distributions Transform | æ­£æ€åˆ†å¸ƒå˜æ¢ï¼Œç”¨äºå¿«é€Ÿç‚¹äº‘é…å‡† | 2.2.2, 2.3 |
| **Kalman Filter** | - | å¡å°”æ›¼æ»¤æ³¢ï¼Œç”¨äºçŠ¶æ€ä¼°è®¡å’Œä¼ æ„Ÿå™¨èåˆ | 3.3 |
| **CycleGAN** | Cycle-Consistent GAN | å¾ªç¯ä¸€è‡´ç”Ÿæˆå¯¹æŠ—ç½‘ç»œï¼Œç”¨äºåŸŸé€‚åº” | 12.3 |
| **Sim-to-Real** | Simulation to Real | ä»¿çœŸåˆ°çœŸå®çš„è¿ç§»ï¼Œå°†ä»¿çœŸè®­ç»ƒçš„æ¨¡å‹åº”ç”¨åˆ°çœŸå®ç¯å¢ƒ | 12.3 |
| **ros2_control** | - | ROS2çš„å®æ—¶æ§åˆ¶æ¡†æ¶ | 2.6, 7.2 |
| **Action** | - | ROS2ä¸­çš„é•¿æ—¶é—´å¼‚æ­¥ä»»åŠ¡é€šä¿¡æœºåˆ¶ | 9.1 |
| **Service** | - | ROS2ä¸­çš„åŒæ­¥è¯·æ±‚-å“åº”é€šä¿¡æœºåˆ¶ | 9.1 |
| **Topic** | - | ROS2ä¸­çš„å¼‚æ­¥å‘å¸ƒ-è®¢é˜…é€šä¿¡æœºåˆ¶ | 9.1 |

### æœ¯è¯­ä½¿ç”¨å»ºè®®

1. **æ–‡æ¡£å¼•ç”¨**ï¼šä½¿ç”¨æœ¯è¯­æ—¶åº”ä¿æŒä¸­è‹±æ–‡ä¸€è‡´æ€§
2. **ä»£ç æ³¨é‡Š**ï¼šä¼˜å…ˆä½¿ç”¨è‹±æ–‡ç¼©å†™ï¼Œæ³¨é‡Šä¸­å¯æ·»åŠ ä¸­æ–‡è§£é‡Š
3. **å›¢é˜Ÿæ²Ÿé€š**ï¼šæ ¹æ®å›¢é˜Ÿä¹ æƒ¯é€‰æ‹©ä¸­æ–‡æˆ–è‹±æ–‡æœ¯è¯­
4. **å­¦ä¹ è·¯å¾„**ï¼šæ–°æ‰‹å¯å…ˆç†è§£ä¸­æ–‡å«ä¹‰ï¼Œå†è®°å¿†è‹±æ–‡ç¼©å†™

### ç›¸å…³èµ„æº

- **ROS2å®˜æ–¹æ–‡æ¡£**ï¼šhttps://docs.ros.org/en/humble/
- **MoveIt2æ–‡æ¡£**ï¼šhttps://moveit.picknik.ai/humble/index.html
- **PCLæ•™ç¨‹**ï¼šhttps://pcl.readthedocs.io/
- **YOLOå®˜æ–¹**ï¼šhttps://docs.ultralytics.com/
- **æœ¯è¯­è¯å…¸**ï¼šæœºå™¨äººå­¦æœ¯è¯­åœ¨çº¿è¯å…¸ (robotics-dictionary.org)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.1  
**æœ€åæ›´æ–°**ï¼š2025 å¹´ 1 æœˆ  
**ä½œè€…**ï¼šAI ç ”ç©¶åŠ©æ‰‹  
**é€‚ç”¨é¡¹ç›®**ï¼š3C é¢†åŸŸè§†è§‰å¼•å¯¼æœºæ¢°è‡‚æŠ“å–ç³»ç»Ÿ  

**å˜æ›´æ—¥å¿—**ï¼š
- v1.1 (2025-01): æ–°å¢å®Œæ•´ä»£ç åº“é“¾æ¥ã€å¿«é€ŸæŸ¥æ‰¾è¡¨ã€Mermaidæµç¨‹å›¾ã€é”™è¯¯å¤„ç†ç« èŠ‚ã€æ•°æ®é›†å‡†å¤‡ç« èŠ‚ã€æœ¯è¯­è¡¨
- v1.0 (2025-01): åˆå§‹ç‰ˆæœ¬ï¼ŒåŒ…å«ç³»ç»Ÿæ¶æ„ã€æŠ€æœ¯æ ˆã€æµç¨‹è¯¦è§£
