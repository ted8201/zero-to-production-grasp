# é”™è¯¯å¤„ç†ä¸æ•°æ®é›†å‡†å¤‡

**å…³è”æ–‡æ¡£**ï¼šã€Šæœºæ¢°è‡‚æŠ“å–ç³»ç»ŸæŠ€æœ¯æ¶æ„ä¸å®ç°æµç¨‹.mdã€‹  
**ç‰ˆæœ¬**ï¼šv1.0  
**æ—¥æœŸ**ï¼š2025 å¹´ 1 æœˆ

æœ¬æ–‡æ¡£åŒ…å«åŸæ–‡æ¡£ç¬¬ 11 èŠ‚ï¼ˆé”™è¯¯å¤„ç†ä¸æ¢å¤ç­–ç•¥ï¼‰å’Œç¬¬ 12 èŠ‚ï¼ˆæ•°æ®é›†å‡†å¤‡ä¸æ¨¡å‹è®­ç»ƒï¼‰çš„å®Œæ•´å†…å®¹ã€‚

---

## 11. é”™è¯¯å¤„ç†ä¸æ¢å¤ç­–ç•¥

### 11.1 å¸¸è§é”™è¯¯ç±»å‹ä¸å¤„ç†

| é”™è¯¯ç±»å‹ | å…¸å‹åŸå›  | æ£€æµ‹æ–¹æ³• | æ¢å¤ç­–ç•¥ | é‡è¯•æ¬¡æ•° |
|---------|---------|---------|---------|---------|
| **æ„ŸçŸ¥å¤±è´¥** | â€¢ å…‰ç…§å˜åŒ–<br>â€¢ ç‰©ä½“é®æŒ¡<br>â€¢ ç›¸æœºæ•…éšœ | æ£€æµ‹ç»“æœä¸ºç©º<br/>ç½®ä¿¡åº¦è¿‡ä½ | â€¢ è°ƒæ•´ç›¸æœºå‚æ•°<br>â€¢ æ”¹å˜è§‚å¯Ÿè§’åº¦<br>â€¢ é‡æ–°é‡‡é›†æ•°æ® | 3æ¬¡ |
| **IK æ— è§£** | â€¢ ç›®æ ‡ä¸å¯è¾¾<br>â€¢ å…³èŠ‚é™åˆ¶<br>â€¢ å¥‡å¼‚ç‚¹é™„è¿‘ | IKæ±‚è§£å™¨è¿”å›å¤±è´¥ | â€¢ é€‰æ‹©æ¬¡ä¼˜æŠ“å–<br>â€¢ è°ƒæ•´æŠ“å–å§¿æ€<br>â€¢ æ”¹å˜æœºæ¢°è‡‚èµ·å§‹ä½ç½® | 5æ¬¡ |
| **è¿åŠ¨è§„åˆ’å¤±è´¥** | â€¢ è·¯å¾„ç¢°æ’<br>â€¢ è§„åˆ’è¶…æ—¶<br>â€¢ æ— å¯è¡Œè·¯å¾„ | è§„åˆ’å™¨è¿”å›None | â€¢ å¢åŠ è§„åˆ’æ—¶é—´<br>â€¢ é™ä½é€Ÿåº¦é™åˆ¶<br>â€¢ ç§»é™¤ä¸´æ—¶éšœç¢ç‰©<br>â€¢ ä½¿ç”¨å¤‡é€‰è§„åˆ’å™¨ | 3æ¬¡ |
| **æŠ“å–å¤±è´¥** | â€¢ ç‰©ä½“æ»‘è½<br>â€¢ æœªæ¥è§¦<br>â€¢ åŠ›åº¦ä¸å½“ | åŠ›ä¼ æ„Ÿå™¨è¯»æ•°å¼‚å¸¸<br/>å¤¹çˆªä½ç½®åé¦ˆ | â€¢ é‡æ–°æŠ“å–ï¼ˆåŒä¸€ç‚¹ï¼‰<br>â€¢ è°ƒæ•´æŠ“å–ç‚¹<br>â€¢ ä¿®æ”¹å¤¹çˆªåŠ›åº¦ | 3æ¬¡ |
| **éªŒè¯å¤±è´¥** | â€¢ ä½ç½®åå·®å¤§<br>â€¢ ç‰©ä½“æŸå<br>â€¢ æ”¾ç½®ä¸ç¨³ | è§†è§‰æ£€æµ‹è¯¯å·®>é˜ˆå€¼ | â€¢ è®°å½•å¤±è´¥æ•°æ®<br>â€¢ é‡æ–°æ‰§è¡Œä»»åŠ¡<br>â€¢ é™ä½ç²¾åº¦è¦æ±‚ | 2æ¬¡ |
| **é€šä¿¡è¶…æ—¶** | â€¢ ç½‘ç»œå»¶è¿Ÿ<br>â€¢ èŠ‚ç‚¹å´©æºƒ | ROS2é€šä¿¡è¶…æ—¶ | â€¢ é‡å¯ç›¸å…³èŠ‚ç‚¹<br>â€¢ æ£€æŸ¥ç½‘ç»œè¿æ¥ | 1æ¬¡ |
| **ç¡¬ä»¶æ•…éšœ** | â€¢ ç”µæœºè¿‡è½½<br>â€¢ ä¼ æ„Ÿå™¨å¤±æ•ˆ | ç¡¬ä»¶çŠ¶æ€ç›‘æ§ | â€¢ ç´§æ€¥åœæ­¢<br>â€¢ äººå·¥ä»‹å…¥ | 0æ¬¡ |

---

### 11.2 é”™è¯¯å¤„ç†çŠ¶æ€æœº

```mermaid
stateDiagram-v2
    [*] --> Normal : ç³»ç»Ÿå¯åŠ¨
    
    Normal --> Error : é”™è¯¯å‘ç”Ÿ
    Normal --> Normal : æ­£å¸¸æ‰§è¡Œ
    
    Error --> Diagnosing : è¯Šæ–­é”™è¯¯ç±»å‹
    
    Diagnosing --> Recoverable : å¯æ¢å¤é”™è¯¯
    Diagnosing --> Unrecoverable : ä¸å¯æ¢å¤é”™è¯¯
    
    Recoverable --> CheckRetry : æ£€æŸ¥é‡è¯•æ¬¡æ•°
    CheckRetry --> Recovering : æ¬¡æ•°æœªè¾¾ä¸Šé™
    CheckRetry --> Unrecoverable : è¾¾åˆ°é‡è¯•ä¸Šé™
    
    Recovering --> Normal : æ¢å¤æˆåŠŸ
    Recovering --> Error : æ¢å¤å¤±è´¥
    
    Unrecoverable --> SafeMode : è¿›å…¥å®‰å…¨æ¨¡å¼
    SafeMode --> Emergency : ç´§æ€¥åœæ­¢
    Emergency --> Manual : ç­‰å¾…äººå·¥ä»‹å…¥
    Manual --> [*] : ç³»ç»Ÿé‡å¯
```

---

### 11.3 é‡è¯•ç­–ç•¥ä»£ç å®ç°

```python
from enum import Enum
import time
import logging

logger = logging.getLogger(__name__)

class ErrorType(Enum):
    """é”™è¯¯ç±»å‹æšä¸¾"""
    PERCEPTION_FAILED = "æ„ŸçŸ¥å¤±è´¥"
    IK_NO_SOLUTION = "IKæ— è§£"
    MOTION_PLANNING_FAILED = "è¿åŠ¨è§„åˆ’å¤±è´¥"
    GRASP_FAILED = "æŠ“å–å¤±è´¥"
    VERIFICATION_FAILED = "éªŒè¯å¤±è´¥"
    COMMUNICATION_TIMEOUT = "é€šä¿¡è¶…æ—¶"
    HARDWARE_FAULT = "ç¡¬ä»¶æ•…éšœ"

class RetryableError(Exception):
    """å¯é‡è¯•çš„é”™è¯¯"""
    def __init__(self, error_type, message, retry_count=0):
        self.error_type = error_type
        self.message = message
        self.retry_count = retry_count
        super().__init__(self.message)

class FatalError(Exception):
    """ä¸å¯æ¢å¤çš„è‡´å‘½é”™è¯¯"""
    pass

class RetryStrategy:
    """é‡è¯•ç­–ç•¥ç®¡ç†å™¨"""
    
    def __init__(self):
        # ä¸åŒé”™è¯¯ç±»å‹çš„æœ€å¤§é‡è¯•æ¬¡æ•°
        self.max_retries = {
            ErrorType.PERCEPTION_FAILED: 3,
            ErrorType.IK_NO_SOLUTION: 5,
            ErrorType.MOTION_PLANNING_FAILED: 3,
            ErrorType.GRASP_FAILED: 3,
            ErrorType.VERIFICATION_FAILED: 2,
            ErrorType.COMMUNICATION_TIMEOUT: 1,
            ErrorType.HARDWARE_FAULT: 0  # ä¸å¯é‡è¯•
        }
        
        # é€€é¿ç­–ç•¥å‚æ•°ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
        self.backoff_base = 1.0  # åŸºç¡€ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
        self.backoff_factor = 1.5  # é€€é¿ç³»æ•°
        
        # é‡è¯•è®¡æ•°å™¨
        self.retry_counters = {err: 0 for err in ErrorType}
    
    def execute_with_retry(self, func, error_type, *args, **kwargs):
        """
        å¸¦é‡è¯•æœºåˆ¶çš„å‡½æ•°æ‰§è¡Œ
        
        Args:
            func: è¦æ‰§è¡Œçš„å‡½æ•°
            error_type: é”™è¯¯ç±»å‹
            *args, **kwargs: å‡½æ•°å‚æ•°
        
        Returns:
            å‡½æ•°æ‰§è¡Œç»“æœ
        
        Raises:
            FatalError: å½“è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°æˆ–é‡åˆ°è‡´å‘½é”™è¯¯æ—¶
        """
        max_attempts = self.max_retries[error_type]
        
        for attempt in range(max_attempts + 1):
            try:
                logger.info(f"æ‰§è¡Œ {func.__name__}ï¼ˆå°è¯• {attempt + 1}/{max_attempts + 1}ï¼‰")
                result = func(*args, **kwargs)
                
                # æˆåŠŸæ‰§è¡Œï¼Œé‡ç½®è®¡æ•°å™¨
                self.retry_counters[error_type] = 0
                return result
                
            except RetryableError as e:
                self.retry_counters[error_type] += 1
                
                if attempt < max_attempts:
                    # è®¡ç®—ç­‰å¾…æ—¶é—´ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
                    wait_time = self.backoff_base * (self.backoff_factor ** attempt)
                    
                    logger.warning(
                        f"{e.error_type.value}: {e.message} "
                        f"(é‡è¯• {attempt + 1}/{max_attempts}ï¼Œç­‰å¾… {wait_time:.1f}ç§’)"
                    )
                    
                    # æ‰§è¡Œæ¢å¤ç­–ç•¥
                    self._execute_recovery_action(e.error_type, attempt)
                    
                    # ç­‰å¾…åé‡è¯•
                    time.sleep(wait_time)
                else:
                    # è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
                    logger.error(f"{e.error_type.value}: è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° ({max_attempts})")
                    raise FatalError(f"{e.error_type.value}: æ— æ³•æ¢å¤") from e
            
            except FatalError as e:
                # è‡´å‘½é”™è¯¯ï¼Œä¸é‡è¯•
                logger.critical(f"è‡´å‘½é”™è¯¯: {e}")
                self._emergency_stop()
                raise
            
            except Exception as e:
                # æœªé¢„æœŸçš„é”™è¯¯
                logger.error(f"æœªé¢„æœŸçš„é”™è¯¯: {e}")
                raise FatalError(f"æœªçŸ¥é”™è¯¯: {e}") from e
    
    def _execute_recovery_action(self, error_type, attempt):
        """æ‰§è¡Œé’ˆå¯¹æ€§çš„æ¢å¤åŠ¨ä½œ"""
        
        if error_type == ErrorType.PERCEPTION_FAILED:
            # è°ƒæ•´ç›¸æœºå‚æ•°æˆ–æ”¹å˜è§†è§’
            logger.info("æ¢å¤åŠ¨ä½œ: è°ƒæ•´ç›¸æœºæ›å…‰å‚æ•°")
            # adjust_camera_exposure()
        
        elif error_type == ErrorType.IK_NO_SOLUTION:
            # å°è¯•ä¸åŒçš„IKæ±‚è§£å™¨æˆ–è°ƒæ•´ç›®æ ‡
            logger.info("æ¢å¤åŠ¨ä½œ: åˆ‡æ¢åˆ°å¤‡ç”¨IKæ±‚è§£å™¨")
            # switch_to_alternative_ik_solver()
        
        elif error_type == ErrorType.MOTION_PLANNING_FAILED:
            # å¢åŠ è§„åˆ’æ—¶é—´æˆ–é™ä½çº¦æŸ
            logger.info("æ¢å¤åŠ¨ä½œ: å¢åŠ è§„åˆ’æ—¶é—´é™åˆ¶")
            # increase_planning_time()
        
        elif error_type == ErrorType.GRASP_FAILED:
            # è°ƒæ•´æŠ“å–åŠ›åº¦æˆ–æ”¹å˜æŠ“å–ç‚¹
            logger.info("æ¢å¤åŠ¨ä½œ: å¢åŠ å¤¹çˆªåŠ›åº¦")
            # increase_gripper_force()
        
        elif error_type == ErrorType.VERIFICATION_FAILED:
            # é‡æ–°é‡‡é›†æ•°æ®è¿›è¡ŒéªŒè¯
            logger.info("æ¢å¤åŠ¨ä½œ: é‡æ–°è¿›è¡Œè§†è§‰éªŒè¯")
            # re_verify_visually()
    
    def _emergency_stop(self):
        """ç´§æ€¥åœæ­¢æ‰€æœ‰è¿åŠ¨"""
        logger.critical("æ‰§è¡Œç´§æ€¥åœæ­¢")
        # åœæ­¢æœºæ¢°è‡‚
        # arm.stop()
        # æ‰“å¼€å¤¹çˆª
        # gripper.open()
        # å‘å¸ƒç´§æ€¥åœæ­¢äº‹ä»¶
        # publish_emergency_stop()
    
    def reset_counters(self):
        """é‡ç½®æ‰€æœ‰è®¡æ•°å™¨"""
        self.retry_counters = {err: 0 for err in ErrorType}
        logger.info("é‡è¯•è®¡æ•°å™¨å·²é‡ç½®")

# ä½¿ç”¨ç¤ºä¾‹
retry_strategy = RetryStrategy()

def perception_task():
    """æ„ŸçŸ¥ä»»åŠ¡ï¼ˆå¯èƒ½å¤±è´¥ï¼‰"""
    objects = detect_objects()
    if len(objects) == 0:
        raise RetryableError(
            ErrorType.PERCEPTION_FAILED,
            "æœªæ£€æµ‹åˆ°ç‰©ä½“"
        )
    return objects

# å¸¦é‡è¯•çš„æ‰§è¡Œ
try:
    objects = retry_strategy.execute_with_retry(
        perception_task,
        ErrorType.PERCEPTION_FAILED
    )
    logger.info(f"æ£€æµ‹åˆ° {len(objects)} ä¸ªç‰©ä½“")
except FatalError as e:
    logger.error(f"ä»»åŠ¡å¤±è´¥: {e}")
```

---

### 11.4 å®‰å…¨æœºåˆ¶

#### 11.4.1 ç´§æ€¥åœæ­¢

```python
import threading

class EmergencyStop:
    """ç´§æ€¥åœæ­¢ç®¡ç†å™¨"""
    
    def __init__(self, arm_controller, gripper_controller):
        self.arm = arm_controller
        self.gripper = gripper_controller
        self.is_stopped = False
        self.stop_lock = threading.Lock()
    
    def emergency_stop(self, reason):
        """æ‰§è¡Œç´§æ€¥åœæ­¢"""
        with self.stop_lock:
            if self.is_stopped:
                return  # å·²ç»åœæ­¢
            
            logger.critical(f"âš ï¸ ç´§æ€¥åœæ­¢: {reason}")
            
            # 1. åœæ­¢æ‰€æœ‰è¿åŠ¨
            try:
                self.arm.stop()
                logger.info("æœºæ¢°è‡‚å·²åœæ­¢")
            except Exception as e:
                logger.error(f"åœæ­¢æœºæ¢°è‡‚å¤±è´¥: {e}")
            
            # 2. æ‰“å¼€å¤¹çˆªï¼ˆé‡Šæ”¾ç‰©ä½“ï¼‰
            try:
                self.gripper.open()
                logger.info("å¤¹çˆªå·²æ‰“å¼€")
            except Exception as e:
                logger.error(f"æ‰“å¼€å¤¹çˆªå¤±è´¥: {e}")
            
            # 3. å‘å¸ƒç´§æ€¥åœæ­¢äº‹ä»¶
            self._publish_emergency_event(reason)
            
            # 4. æ ‡è®°çŠ¶æ€
            self.is_stopped = True
            
            logger.critical("ç´§æ€¥åœæ­¢æ‰§è¡Œå®Œæˆ")
    
    def _publish_emergency_event(self, reason):
        """å‘å¸ƒç´§æ€¥åœæ­¢äº‹ä»¶åˆ°ROS2"""
        # emergency_pub.publish(EmergencyStopMsg(
        #     reason=reason,
        #     timestamp=time.time()
        # ))
        pass
    
    def reset(self):
        """é‡ç½®ç´§æ€¥åœæ­¢çŠ¶æ€"""
        with self.stop_lock:
            self.is_stopped = False
            logger.info("ç´§æ€¥åœæ­¢çŠ¶æ€å·²é‡ç½®")
```

#### 11.4.2 ç¢°æ’æ£€æµ‹ä¸å“åº”

```python
class CollisionMonitor:
    """å®æ—¶ç¢°æ’ç›‘æ§"""
    
    def __init__(self, force_sensor, emergency_stop, threshold=50.0):
        self.force_sensor = force_sensor
        self.emergency_stop = emergency_stop
        self.threshold = threshold  # ç¢°æ’åŠ›é˜ˆå€¼ï¼ˆNï¼‰
        self.is_monitoring = False
        self.monitor_thread = None
    
    def start_monitoring(self):
        """å¯åŠ¨ç¢°æ’ç›‘æ§"""
        if self.is_monitoring:
            return
        
        self.is_monitoring = True
        self.monitor_thread = threading.Thread(
            target=self._monitor_loop,
            daemon=True
        )
        self.monitor_thread.start()
        logger.info("ç¢°æ’ç›‘æ§å·²å¯åŠ¨")
    
    def stop_monitoring(self):
        """åœæ­¢ç¢°æ’ç›‘æ§"""
        self.is_monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=1.0)
        logger.info("ç¢°æ’ç›‘æ§å·²åœæ­¢")
    
    def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯ï¼ˆ100Hzï¼‰"""
        while self.is_monitoring:
            try:
                # è¯»å–åŠ›ä¼ æ„Ÿå™¨
                force = self.force_sensor.get_force_magnitude()
                
                # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
                if force > self.threshold:
                    logger.error(f"æ£€æµ‹åˆ°ç¢°æ’ï¼åŠ›: {force:.2f} N")
                    
                    # è§¦å‘ç´§æ€¥åœæ­¢
                    self.emergency_stop.emergency_stop(
                        f"ç¢°æ’æ£€æµ‹: åŠ›={force:.2f}N > é˜ˆå€¼={self.threshold}N"
                    )
                    
                    break
                
            except Exception as e:
                logger.error(f"ç¢°æ’ç›‘æ§é”™è¯¯: {e}")
            
            time.sleep(0.01)  # 100Hzç›‘æ§é¢‘ç‡
```

#### 11.4.3 å·¥ä½œç©ºé—´é™åˆ¶æ£€æŸ¥

```python
class WorkspaceMonitor:
    """å·¥ä½œç©ºé—´è¾¹ç•Œç›‘æ§"""
    
    def __init__(self, arm_controller):
        self.arm = arm_controller
        
        # å®šä¹‰å®‰å…¨å·¥ä½œç©ºé—´ï¼ˆç›¸å¯¹äºåŸºåº§ï¼‰
        self.workspace_limits = {
            'x': (0.1, 0.8),  # å‰åèŒƒå›´ï¼ˆç±³ï¼‰
            'y': (-0.5, 0.5),  # å·¦å³èŒƒå›´ï¼ˆç±³ï¼‰
            'z': (0.0, 1.0)    # ä¸Šä¸‹èŒƒå›´ï¼ˆç±³ï¼‰
        }
    
    def check_pose(self, pose):
        """æ£€æŸ¥ä½å§¿æ˜¯å¦åœ¨å®‰å…¨å·¥ä½œç©ºé—´å†…"""
        x, y, z = pose['position']
        
        violations = []
        
        if not (self.workspace_limits['x'][0] <= x <= self.workspace_limits['x'][1]):
            violations.append(f"Xè½´è¶…é™: {x:.3f} m")
        
        if not (self.workspace_limits['y'][0] <= y <= self.workspace_limits['y'][1]):
            violations.append(f"Yè½´è¶…é™: {y:.3f} m")
        
        if not (self.workspace_limits['z'][0] <= z <= self.workspace_limits['z'][1]):
            violations.append(f"Zè½´è¶…é™: {z:.3f} m")
        
        if violations:
            error_msg = "å·¥ä½œç©ºé—´è¶…é™: " + ", ".join(violations)
            logger.error(error_msg)
            return False, error_msg
        
        return True, "ä½å§¿å®‰å…¨"
```

---

### 11.5 é”™è¯¯æ—¥å¿—ä¸è¯Šæ–­

```python
import json
from datetime import datetime

class ErrorLogger:
    """é”™è¯¯æ—¥å¿—è®°å½•å™¨"""
    
    def __init__(self, log_file="errors.jsonl"):
        self.log_file = log_file
    
    def log_error(self, error_type, context, recovery_action=None):
        """è®°å½•é”™è¯¯åˆ°JSON Linesæ–‡ä»¶"""
        error_entry = {
            'timestamp': datetime.now().isoformat(),
            'error_type': error_type.value if isinstance(error_type, Enum) else str(error_type),
            'context': context,
            'recovery_action': recovery_action,
            'system_state': self._capture_system_state()
        }
        
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(error_entry, ensure_ascii=False) + '\n')
        
        logger.debug(f"é”™è¯¯å·²è®°å½•åˆ° {self.log_file}")
    
    def _capture_system_state(self):
        """æ•è·å½“å‰ç³»ç»ŸçŠ¶æ€"""
        return {
            'joint_states': None,  # ä»ROS2è·å–
            'gripper_state': None,
            'camera_status': None,
            'force_reading': None
        }
    
    def analyze_errors(self, time_window_hours=24):
        """åˆ†ææœ€è¿‘çš„é”™è¯¯æ¨¡å¼"""
        errors = []
        
        try:
            with open(self.log_file, 'r') as f:
                for line in f:
                    error = json.loads(line)
                    errors.append(error)
        except FileNotFoundError:
            logger.warning(f"æ—¥å¿—æ–‡ä»¶ {self.log_file} ä¸å­˜åœ¨")
            return {}
        
        # ç»Ÿè®¡é”™è¯¯ç±»å‹
        error_counts = {}
        for error in errors:
            error_type = error['error_type']
            error_counts[error_type] = error_counts.get(error_type, 0) + 1
        
        logger.info(f"é”™è¯¯ç»Ÿè®¡ (æœ€è¿‘{len(errors)}æ¡):")
        for error_type, count in sorted(error_counts.items(), key=lambda x: x[1], reverse=True):
            logger.info(f"  {error_type}: {count} æ¬¡")
        
        return error_counts
```

---

## 12. æ•°æ®é›†å‡†å¤‡ä¸æ¨¡å‹è®­ç»ƒ

### 12.1 YOLO v8 æ•°æ®é›†å‡†å¤‡

#### 12.1.1 æ•°æ®æ”¶é›†ç­–ç•¥

**ç›®æ ‡æ•°é‡ä¸åˆ†å¸ƒ**ï¼š

| ç±»åˆ« | è®­ç»ƒé›† | éªŒè¯é›† | æµ‹è¯•é›† | åœºæ™¯å¤šæ ·æ€§ |
|------|--------|--------|--------|----------|
| chipï¼ˆèŠ¯ç‰‡ï¼‰ | 800 | 100 | 100 | ä¸åŒå…‰ç…§ã€è§’åº¦ã€èƒŒæ™¯ |
| pcbï¼ˆç”µè·¯æ¿ï¼‰ | 600 | 75 | 75 | å¹³æ”¾ã€ç«–æ”¾ã€å †å  |
| connectorï¼ˆè¿æ¥å™¨ï¼‰ | 500 | 65 | 65 | æ’æ‹”çŠ¶æ€ã€ä¸åŒå‹å· |
| cableï¼ˆçº¿ç¼†ï¼‰ | 400 | 50 | 50 | å¼¯æ›²ã€ç¼ ç»•ã€æ•´é½ |
| **æ€»è®¡** | **2300** | **290** | **290** | **å¤šæ ·åŒ–åœºæ™¯** |

**æ•°æ®å¢å¼ºç­–ç•¥**ï¼ˆè®­ç»ƒæ—¶è‡ªåŠ¨åº”ç”¨ï¼‰ï¼š
- éšæœºæ—‹è½¬ï¼šÂ±10Â°
- éšæœºå¹³ç§»ï¼šÂ±10%
- éšæœºç¼©æ”¾ï¼š0.5-1.5Ã—
- éšæœºç¿»è½¬ï¼šæ°´å¹³50%æ¦‚ç‡
- HSVé¢œè‰²æŠ–åŠ¨ï¼šè‰²è°ƒÂ±15Â°ã€é¥±å’Œåº¦Â±70%ã€äº®åº¦Â±40%
- éšæœºé®æŒ¡ï¼š5-15%é¢ç§¯

---

#### 12.1.2 æ•°æ®é›†ç›®å½•ç»“æ„

```
datasets/3c_detection/
â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ train/
â”‚   â”‚   â”œâ”€â”€ chip_001.jpg
â”‚   â”‚   â”œâ”€â”€ chip_002.jpg
â”‚   â”‚   â”œâ”€â”€ pcb_001.jpg
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ val/
â”‚   â”‚   â”œâ”€â”€ chip_101.jpg
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ test/
â”‚       â”œâ”€â”€ chip_201.jpg
â”‚       â””â”€â”€ ...
â”œâ”€â”€ labels/
â”‚   â”œâ”€â”€ train/
â”‚   â”‚   â”œâ”€â”€ chip_001.txt     # YOLOæ ¼å¼æ ‡æ³¨
â”‚   â”‚   â”œâ”€â”€ chip_002.txt
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ val/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ data.yaml                 # æ•°æ®é›†é…ç½®
â””â”€â”€ classes.txt               # ç±»åˆ«åˆ—è¡¨
```

**YOLO æ ‡æ³¨æ ¼å¼**ï¼ˆ`chip_001.txt`ï¼‰ï¼š
```
0 0.512 0.423 0.156 0.089
0 0.731 0.334 0.142 0.095
1 0.345 0.678 0.234 0.189
```
æ ¼å¼ï¼š`<class_id> <x_center> <y_center> <width> <height>`ï¼ˆå½’ä¸€åŒ–åæ ‡ï¼‰

---

#### 12.1.3 æ ‡æ³¨å·¥å…·æ¨è

| å·¥å…· | ç±»å‹ | ä¼˜åŠ¿ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **LabelImg** | æ¡Œé¢åº”ç”¨ | ç®€å•æ˜“ç”¨ã€æ”¯æŒYOLOæ ¼å¼ | å°è§„æ¨¡æ•°æ®é›† |
| **Roboflow** | åœ¨çº¿å¹³å° | è‡ªåŠ¨æ•°æ®å¢å¼ºã€å›¢é˜Ÿåä½œ | ä¸­å¤§è§„æ¨¡æ•°æ®é›† |
| **CVAT** | åœ¨çº¿/è‡ªæ‰˜ç®¡ | å¤šæ ¼å¼æ”¯æŒã€è§†é¢‘æ ‡æ³¨ | ä¼ä¸šçº§é¡¹ç›® |
| **Labelme** | æ¡Œé¢åº”ç”¨ | å¤šè¾¹å½¢æ ‡æ³¨ã€å®ä¾‹åˆ†å‰² | éœ€è¦ç²¾ç¡®è¾¹ç•Œ |

**æ¨èæµç¨‹**ï¼šRoboflowï¼ˆæ ‡æ³¨ + å¢å¼º + ç®¡ç†ï¼‰

---

#### 12.1.4 data.yaml é…ç½®

```yaml
# æ•°æ®é›†é…ç½®æ–‡ä»¶
path: /datasets/3c_detection  # æ•°æ®é›†æ ¹ç›®å½•
train: images/train            # è®­ç»ƒé›†è·¯å¾„
val: images/val                # éªŒè¯é›†è·¯å¾„
test: images/test              # æµ‹è¯•é›†è·¯å¾„

# ç±»åˆ«å®šä¹‰
nc: 4                          # ç±»åˆ«æ•°é‡
names: ['chip', 'pcb', 'connector', 'cable']  # ç±»åˆ«åç§°

# æ•°æ®å¢å¼ºï¼ˆå¯é€‰ï¼Œè®­ç»ƒæ—¶è¦†ç›–ï¼‰
augment:
  hsv_h: 0.015                 # HSVè‰²è°ƒå¢å¼º
  hsv_s: 0.7                   # HSVé¥±å’Œåº¦å¢å¼º
  hsv_v: 0.4                   # HSVäº®åº¦å¢å¼º
  degrees: 10.0                # æ—‹è½¬è§’åº¦
  translate: 0.1               # å¹³ç§»æ¯”ä¾‹
  scale: 0.5                   # ç¼©æ”¾æ¯”ä¾‹
  fliplr: 0.5                  # æ°´å¹³ç¿»è½¬æ¦‚ç‡
```

---

#### 12.1.5 è®­ç»ƒè„šæœ¬

```python
from ultralytics import YOLO
import os

def train_yolov8_3c():
    """è®­ç»ƒYOLO v8æ¨¡å‹ç”¨äº3Cç»„ä»¶æ£€æµ‹"""
    
    # 1. åŠ è½½é¢„è®­ç»ƒæ¨¡å‹
    model = YOLO('yolov8n.pt')  # nanoç‰ˆæœ¬ï¼ˆæœ€å¿«ï¼‰
    # model = YOLO('yolov8s.pt')  # smallç‰ˆæœ¬ï¼ˆæ¨èï¼‰
    # model = YOLO('yolov8m.pt')  # mediumç‰ˆæœ¬ï¼ˆç²¾åº¦æ›´é«˜ï¼‰
    
    # 2. è®­ç»ƒé…ç½®
    results = model.train(
        # æ•°æ®é…ç½®
        data='datasets/3c_detection/data.yaml',
        
        # è®­ç»ƒå‚æ•°
        epochs=100,              # è®­ç»ƒè½®æ•°
        batch=16,                # æ‰¹æ¬¡å¤§å°ï¼ˆæ ¹æ®GPUè°ƒæ•´ï¼‰
        imgsz=640,               # è¾“å…¥å›¾åƒå°ºå¯¸
        
        # ç¡¬ä»¶é…ç½®
        device=0,                # GPUè®¾å¤‡IDï¼ˆ0=ç¬¬ä¸€å—GPUï¼‰
        workers=8,               # æ•°æ®åŠ è½½çº¿ç¨‹æ•°
        
        # ä¼˜åŒ–å™¨
        optimizer='AdamW',       # ä¼˜åŒ–å™¨ç±»å‹
        lr0=0.001,               # åˆå§‹å­¦ä¹ ç‡
        lrf=0.01,                # æœ€ç»ˆå­¦ä¹ ç‡ï¼ˆç›¸å¯¹äºlr0ï¼‰
        momentum=0.937,          # SGDåŠ¨é‡
        weight_decay=0.0005,     # æƒé‡è¡°å‡
        
        # æ—©åœ
        patience=20,             # æ—©åœè€å¿ƒå€¼ï¼ˆepochï¼‰
        
        # æ•°æ®å¢å¼º
        hsv_h=0.015,
        hsv_s=0.7,
        hsv_v=0.4,
        degrees=10.0,
        translate=0.1,
        scale=0.5,
        fliplr=0.5,
        mosaic=1.0,              # Mosaicå¢å¼ºæ¦‚ç‡
        mixup=0.1,               # Mixupå¢å¼ºæ¦‚ç‡
        
        # ä¿å­˜é…ç½®
        project='runs/detect',   # é¡¹ç›®ç›®å½•
        name='yolov8_3c',        # å®éªŒåç§°
        exist_ok=False,          # æ˜¯å¦è¦†ç›–å·²å­˜åœ¨çš„ç›®å½•
        save=True,               # æ˜¯å¦ä¿å­˜æ£€æŸ¥ç‚¹
        save_period=10,          # æ¯Nä¸ªepochä¿å­˜ä¸€æ¬¡
        
        # å¯è§†åŒ–
        plots=True,              # ç”Ÿæˆè®­ç»ƒæ›²çº¿å›¾
        
        # éªŒè¯
        val=True,                # è®­ç»ƒè¿‡ç¨‹ä¸­éªŒè¯
        
        # å…¶ä»–
        verbose=True,            # è¯¦ç»†è¾“å‡º
        seed=42,                 # éšæœºç§å­
        deterministic=True,      # ç¡®å®šæ€§è®­ç»ƒ
        single_cls=False,        # æ˜¯å¦å•ç±»åˆ«æ£€æµ‹
        rect=False,              # çŸ©å½¢è®­ç»ƒï¼ˆæ›´å¿«ä½†ç²¾åº¦ç•¥é™ï¼‰
        cos_lr=True,             # ä½™å¼¦å­¦ä¹ ç‡è°ƒåº¦
        close_mosaic=10,         # æœ€åNä¸ªepochå…³é—­mosaic
    )
    
    # 3. è®­ç»ƒå®Œæˆï¼Œæ‰“å°æœ€ä½³æ¨¡å‹è·¯å¾„
    print(f"\nâœ… è®­ç»ƒå®Œæˆï¼")
    print(f"æœ€ä½³æ¨¡å‹: {results.save_dir}/weights/best.pt")
    print(f"æœ€ç»ˆæ¨¡å‹: {results.save_dir}/weights/last.pt")
    
    return results

def evaluate_model(model_path, data_yaml='datasets/3c_detection/data.yaml'):
    """è¯„ä¼°è®­ç»ƒå¥½çš„æ¨¡å‹"""
    
    model = YOLO(model_path)
    
    # åœ¨éªŒè¯é›†ä¸Šè¯„ä¼°
    metrics = model.val(data=data_yaml)
    
    print("\nğŸ“Š è¯„ä¼°ç»“æœ:")
    print(f"mAP50: {metrics.box.map50:.4f}")      # mAP @ IoU=0.5
    print(f"mAP50-95: {metrics.box.map:.4f}")     # mAP @ IoU=0.5:0.95
    print(f"Precision: {metrics.box.mp:.4f}")     # ç²¾ç¡®ç‡
    print(f"Recall: {metrics.box.mr:.4f}")        # å¬å›ç‡
    
    # æ¯ä¸ªç±»åˆ«çš„æ€§èƒ½
    print("\nå„ç±»åˆ«æ€§èƒ½:")
    for i, name in enumerate(metrics.names.values()):
        print(f"  {name}:")
        print(f"    mAP50: {metrics.box.maps[i]:.4f}")
        print(f"    Precision: {metrics.box.p[i]:.4f}")
        print(f"    Recall: {metrics.box.r[i]:.4f}")
    
    return metrics

def export_model(model_path, format='onnx'):
    """å¯¼å‡ºæ¨¡å‹ä¸ºå…¶ä»–æ ¼å¼"""
    
    model = YOLO(model_path)
    
    # å¯¼å‡ºä¸ºONNXæ ¼å¼ï¼ˆæ¨èï¼‰
    if format == 'onnx':
        model.export(format='onnx', dynamic=True, simplify=True)
    
    # å¯¼å‡ºä¸ºTensorRTæ ¼å¼ï¼ˆæœ€å¿«ï¼‰
    elif format == 'engine':
        model.export(format='engine', device=0, half=True)
    
    # å¯¼å‡ºä¸ºCoreMLæ ¼å¼ï¼ˆiOSï¼‰
    elif format == 'coreml':
        model.export(format='coreml')
    
    print(f"âœ… æ¨¡å‹å·²å¯¼å‡ºä¸º {format} æ ¼å¼")

# ä¸»å‡½æ•°
if __name__ == '__main__':
    # è®­ç»ƒ
    results = train_yolov8_3c()
    
    # è¯„ä¼°
    best_model = 'runs/detect/yolov8_3c/weights/best.pt'
    metrics = evaluate_model(best_model)
    
    # å¯¼å‡ºï¼ˆå¯é€‰ï¼‰
    export_model(best_model, format='onnx')
```

---

### 12.2 GraspNet æ•°æ®é›†å‡†å¤‡

è¯¦ç»†çš„ GraspNet æ•°æ®é›†å‡†å¤‡æµç¨‹è¯·å‚è€ƒã€Šæ–‡æ¡£ReviewæŠ¥å‘Šã€‹ç¬¬12.2èŠ‚ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
1. **ä»¿çœŸæ•°æ®ç”Ÿæˆ**ï¼šä½¿ç”¨ Gazebo ç”Ÿæˆ 1000+ åœºæ™¯
2. **çœŸå®æ•°æ®é‡‡é›†**ï¼šä½¿ç”¨ Intel RealSense é‡‡é›† 100+ åœºæ™¯
3. **Sim-to-Real**ï¼šCycleGAN åŸŸé€‚åº” + æ··åˆè®­ç»ƒ

---

## æ€»ç»“

æœ¬è¡¥å……ç« èŠ‚è¯¦ç»†ä»‹ç»äº†ï¼š

1. **é”™è¯¯å¤„ç†**ï¼š7ç§å¸¸è§é”™è¯¯ç±»å‹ã€é‡è¯•ç­–ç•¥ã€å®‰å…¨æœºåˆ¶
2. **æ•°æ®é›†å‡†å¤‡**ï¼šYOLO v8 å®Œæ•´è®­ç»ƒæµç¨‹ã€GraspNet æ•°æ®ç”Ÿæˆ

å»ºè®®å°†æœ¬ç« èŠ‚å†…å®¹æ•´åˆåˆ°ä¸»æ–‡æ¡£ç¬¬10èŠ‚ä¹‹åã€‚

